<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NSGA-II Optimization for Burrito Builder</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v4.min.js"></script>
    <style>
        /* Global Font Style */
        body {
            font-family: Arial, sans-serif;
            margin: 20px; /* Added margin for overall padding */
        }

        /* Country Styling */
        .country { fill: rgb(143, 204, 245); stroke: white; cursor: pointer; }
        .country:hover { fill: lightblue; }

        /* Tooltip Styling */
        .tooltip {
            position: absolute;
            background-color: white;
            padding: 10px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            color: black;
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 200px;
            white-space: pre-line;
            line-height: 1.4;
            text-align: left;
        }

            /*!* Optional: Add a small arrow/triangle *!*/
            /*&::after {*/
            /*    content: "";*/
            /*    position: absolute;*/
            /*    top: 100%;*/
            /*    left: 50%;*/
            /*    margin-left: -5px;*/
            /*    border-width: 5px;*/
            /*    border-style: solid;*/
            /*    border-color: white transparent transparent transparent;*/
            /*}*/
        }

        /* Label and Line Styling */
        .label { font-size: 14px; font-weight: bold; }
        .line { stroke-width: 1.5; }

        .map-wrapper {
            width: 100%;
            max-width: 1200px; /* Or whatever maximum width you prefer */
            margin: 0;
            position: relative;
        }

        /* Map container layout */
        #map {
            position: relative;
            width: 100%;
        }

        /* Map content container */
        .map-content {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            margin: 0/* Consistent space between map and legend */
        }

        /* Map SVG dimensions */
        #map svg {
            width: 100%;
            height: 500px;
        }

        /* Map Container */
        .map-container {
            position: relative;
            flex: 1;
            min-width: 0;
            margin: 0;/* Prevent flex item overflow */
        }

        #pareto-chart { width: 100%; height: 300px; }

        /* Layout Styling */
        .form-row {
            display: flex;
            align-items: flex-start;
            flex-wrap: wrap;
            margin-bottom: 20px;
            gap: 20px; /* Added gap for consistent spacing */
        }
        .form-column {
            flex: 1;
        }

        .left-column {
            /* Reduced margin-right to narrow the gap */
            margin-right: 10px;
        }

        .right-column {
            /* Removed negative margin-left to prevent overlap and narrow the gap */
            margin-left: 0px;
        }

        /* Adjustments for Pareto Front Visualization */
        #pareto-front {
            margin-top: 0; /* Remove top margin */
            padding-top: 0; /* Remove top padding if any */
        }

        #pareto-front h3 {
            margin-top: 0; /* Remove default top margin from heading */
            margin-bottom: 10px; /* Add some space below the heading */
        }

        /* Highlight Styling for Optimal Solution */
        .optimal-point { 
            fill: red; 
            stroke: black; 
            stroke-width: 2px; 
        }
        .optimal-label {
            font-size: 12px;
            font-weight: bold;
            fill: black;
            background: white;
        }

        /* Slider Styling */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 20px; /* Space between slider and label containers */
            margin-bottom: 10px; /* Added margin for spacing */
        }

        .slider-label-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Add these new styles for the slider appearance */
        input[type="range"] {
            -webkit-appearance: none;
            height: 2px;
            background: #d3d3d3;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            border: 1px solid #888;
            border-radius: 50%;
            cursor: pointer;
            background: black;
        }

        /* Map Header Styling */
        .map-header {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            margin-top: 20px; /* Added margin for spacing */
        }
        #solution-info {
            font-size: 20px;
            font-weight: bold;
            margin-left: 20px;
            color: blue;
        }

        /* Section Label Styling */
        .section-label {
            color: blue;
            font-weight: bold;
        }

        /* Responsive Design (Optional) */
        @media (max-width: 800px) {
            .form-row {
                flex-direction: column;
            }
            .left-column, .right-column {
                margin-right: 0;
                margin-left: 0;
            }
        }

        /* Legend Container Styling */
        .legend-container {
            position: absolute;
            top: 10px;          /* Position at top */
            right: 10px;        /* Position at right */
            width: 150px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-height: 80%;
            overflow-y: auto;
            z-index: 1000;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }

        .color-box {
            width: 15px;
            height: 15px;
            margin-right: 8px;
            border: 1px solid #666;
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        .map-header {
            margin-bottom: 20px;
        }

        .confirmation-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .confirmation-section button {
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .confirmation-section button:hover {
            opacity: 0.9;
        }

        .flex-container {
            display: flex;
            gap: 2rem;
        }

        .ingredient-list {
            flex: 1;
        }

        .burrito-preview {
            flex: 1;
            width: 256px;
            height: 256px;
            position: relative;
        }

        .burrito-preview img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Add new splash screen styles */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #f5d794, #ff9b76);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-in-out;
        }

        .splash-content {
            text-align: center;
            color: #333;
            padding: 2rem;
            max-width: 600px;
        }

        .splash-title {
            font-size: 3rem;
            margin-bottom: 1rem;
            font-weight: bold;
            color: #2d3748;
        }

        .splash-description {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            line-height: 1.6;
            color: #4a5568;
        }

        .start-button {
            padding: 1rem 2rem;
            font-size: 1.2rem;
            background-color: #4a5568;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .start-button:hover {
            background-color: #2d3748;
            transform: translateY(-2px);
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Add this to hide the main content initially */
        .main-content {
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        .main-content.visible {
            opacity: 1;
        }

    </style>
</head>
<body>
    <h2>The Burrito Builder: Cost vs Emissions</h2>

   <div class="splash-screen" id="splashScreen">
        <div class="splash-content">
            <h1 class="splash-title">ðŸŒ¯ Burrito Builder</h1>
            <p class="splash-description">
                Welcome to the Burrito Builder, an interactive tool that helps you create the perfect burrito while considering both cost and environmental impact. This application uses the NSGA-II optimization algorithm to find the best combination of ingredient sources based on your preferences.
            </p>

        <h3 style="margin: 20px 0 10px 0; color: #2c5282;">How to Use the Interface:</h3>
        <ol style="margin-left: 20px; margin-bottom: 20px;">
            <li><strong>Select Your Location:</strong> Choose your country from the dropdown menu. This will determine the available ingredient sources and their associated costs.</li>
            <li><strong>Set Your Budget:</strong> Enter the maximum amount you're willing to spend on your burrito.</li>
            <li><strong>Choose Ingredients:</strong> Select the ingredients you'd like in your burrito. The tortilla is included by default.</li>
            <li><strong>Adjust Preferences:</strong> Use the slider to balance between cost savings (left) and lower environmental impact (right).</li>
        </ol>

        <p style="margin-bottom: 15px;">
            The Pareto front visualization shows all optimal solutions, where each point represents a unique combination of ingredient sources. The world map below displays the source countries for your selected burrito configuration, with your location highlighted in black.
        </p>

        <p style="font-style: italic; color: #666;">
            Note: The environmental impact score is calculated based on factors such as transportation distance and production methods. Lower scores indicate more environmentally friendly choices.
        </p>
        <button class="start-button" id="startButton">Let's Build! ðŸš€</button>
    </div>
   </div>

    <div class = "main-content" id="mainContent">
        <!-- First Row: Location and Budget -->
        <div class="form-row">
            <!-- Left Column -->
            <div class="form-column left-column">
                <!-- Choose your location -->
                <label for="importing-country" class="section-label">Where are you eating your burrito?</label><br>
                <select id="importing-country" style="margin-top:10px;">
                </select><br><br>
            </div>

            <!-- Right Column -->
            <div class="form-column right-column">
                <label for="budget" class="section-label">What's the max you will pay for your burrito?</label><br>
                <div style="margin-top: 7px; display: flex; gap: 10px; align-items: center;">
                    $ <input type="number" id="budget-input" name="budget" value="25" min="0" step="0.01" style="width: 100px;">
                    <button id="update-budget" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                        Update
                    </button>
                </div><br><br>
            </div>
        </div> <!-- Close first form-row -->

        <!-- Second Row: Ingredients and Pareto Front -->
        <div class="form-row">
            <!-- Left Column -->
            <div class="form-column left-column">
                    <!-- Choose ingredients for your burrito -->
                    <label for="ingredient" class="section-label">What's going in your burrito?</label><br><br>
                    <div class="flex-container">
                        <!-- Ingredient checkboxes -->
                        <div class="ingredient-list">
                            <input type="checkbox" id="tortilla" name="tortilla" value="Tortilla" checked disabled> Tortilla (wheat)<br>
                            <input type="checkbox" id="beef" name="beef" value="Beef"> Beef<br>
                            <input type="checkbox" id="chicken" name="chicken" value="Chicken"> Chicken<br>
                            <input type="checkbox" id="pork" name="pork" value="Pork"> Pork<br>
                            <input type="checkbox" id="cheese" name="cheese" value="Cheese"> Cheese<br>
                            <input type="checkbox" id="sour-cream" name="sour-cream" value="Sour Cream"> Sour cream<br>
                            <input type="checkbox" id="rice" name="rice" value="Rice"> Rice<br>
                            <input type="checkbox" id="beans" name="beans" value="Beans"> Beans<br>
                            <input type="checkbox" id="lettuce" name="lettuce" value="Lettuce"> Lettuce<br>
                            <input type="checkbox" id="onions" name="onions" value="Onions"> Onions<br>
                            <input type="checkbox" id="tomatoes" name="tomatoes" value="Tomato"> Tomatoes<br>
                            <input type="checkbox" id="avocado" name="avocado" value="Avocado"> Avocado<br>
                        </div>
                        <!-- Burrito visualization -->
                        <div id="burrito-preview" class="burrito-preview"></div>
                    </div>
                </div>

            <!-- Right Column -->
            <div class="form-column right-column">
                <!-- Pareto Front Visualization -->
                <div id="pareto-front">
                    <h3>Pareto Front Visualization</h3>
                    <svg id="pareto-chart" width="400" height="300"></svg>
                </div>
            </div>
        </div> <!-- Close second form-row -->

        <!-- Set Priorities for Optimization -->
        <h3>What matters more when selecting your burrito?</h3>
        <div class="slider-container">
            <label for="weight-slider">Low Cost</label>
            <input type="range" id="weight-slider" min="0" max="100" step="1" value="50" style="width: 300px;">
            <label for="weight-slider">Low Environmental Impact</label>
        </div>

        <!-- Tooltip for displaying cost and impact -->
        <div class="tooltip" id="tooltip"></div>

        <div class="map-wrapper">
            <div id="map">
                <div class="map-header">
                    <div class="flex justify-between items-center w-full">
                        <div id="solution-info" class="text-left"></div>
                        <div class="confirmation-section">
                            <span>Is this the burrito you want?</span>
                            <button onclick="handleBurritoConfirm(true)" class="bg-green-500 text-white px-4 py-2 mx-2 rounded">Yes</button>
                            <button onclick="handleBurritoConfirm(false)" class="bg-red-500 text-white px-4 py-2 rounded">No</button>
                        </div>
                    </div>
                </div>
                <h3 class="text-xl font-bold mt-4 mb-2">From where are your burrito ingredients?</h3>
                <div class="map-content">
                    <div class="map-container">
                        <svg id="country-map" width="960" height="500"></svg>
                        <div id="map-legend" class="legend-container">
                            <!-- Legend will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <!-- JavaScript Code -->
    <script>

        // Splash screen handling
        document.getElementById('startButton').addEventListener('click', function() {
            const splashScreen = document.getElementById('splashScreen');
            const mainContent = document.getElementById('mainContent');

            // Hide splash screen
            splashScreen.classList.add('hidden');

            // Show main content with a slight delay
            setTimeout(() => {
                mainContent.classList.add('visible');
                // Trigger any initial setup you need
                if (typeof updateParetoFront === 'function') {
                    updateParetoFront();
                }
            }, 500);
        });

        let ingredientData = null;

        // Load ingredient data
        d3.json("final_burrito_data.json").then(function(data) {
            if (!validateIngredientData(data)) {
                throw new Error("Invalid data structure");
            }
            ingredientData = data;
            console.log("Ingredient data loaded:", ingredientData);

            // Find and modify tortilla checkbox
            const tortillaCheckbox = document.getElementById('tortilla');
            if (tortillaCheckbox) {
                tortillaCheckbox.checked = true;  // Check by default
                tortillaCheckbox.disabled = true; // Prevent unchecking
            }

            // Get unique importing countries from the data
            const importingCountries = Object.keys(data);
            console.log("Available importing countries:", importingCountries);

            // Populate the dropdown
            const dropdown = d3.select("#importing-country");

            // Clear existing options
            dropdown.selectAll("option").remove();

            // Add new options and set Australia as the first option
            dropdown.selectAll("option")
                .data(["Australia", ...importingCountries.filter(country => country !== "Australia")])
                .enter()
                .append("option")
                .attr("value", d => d)
                .text(d => d);

            // Set Australia as default
            dropdown.property("value", "Australia");

            // Enable all UI elements
            enableUIElements();

        }).catch(function(error) {
            console.error("Error loading ingredientData.json:", error);
            alert("Error loading ingredient data. Please refresh the page.");
        });

        // Function to enable UI elements - redefine this first
        function enableUIElements() {
            // Enable all checkboxes except tortilla
            d3.selectAll("input[type=checkbox]")
                .filter(function() {
                    return this.id !== 'tortilla';  // Skip the tortilla checkbox
                })
                .property("disabled", false)
                .on("change", function() {
                    updateParetoFront();
                    updateBurritoVisualization();
                });

            // Enable location dropdown
            const locationDropdown = d3.select("#importing-country");
            locationDropdown
                .property("disabled", false)
                .on("change", function() {
                    console.log("Location changed to:", this.value);
                    updateParetoFront();
                });

            // Enable budget input
            const budgetInput = d3.select("#budget-input");
            const updateButton = d3.select("#update-budget");

            // Function to handle budget update
            function updateBudget() {
                const budget = +budgetInput.node().value;
                if (budget <= 0) {
                    alert("Please enter a valid budget greater than 0");
                    budgetInput.node().value = 1;
                    return;
                }
                console.log("Budget changed to:", budget);
                updateParetoFront();
            }

            // Update button click handler
            updateButton.on("click", updateBudget);

            // Enter key handler
            budgetInput.on("keydown", function() {
                if (d3.event.keyCode === 13) { // 13 is the Enter key code
                    d3.event.preventDefault();
                    updateBudget();
                }
            });

            // Enable weight slider
            const weightSlider = d3.select("#weight-slider");
            weightSlider
                .property("disabled", false)
                .on("input", function() {
                    const costWeight = +this.value / 100;
                    const impactWeight = 1 - costWeight;



                    console.log("Weights updated - Cost:", (1 - costWeight) * 100, "% Impact:", costWeight * 100, "%");
                    updateParetoFront();
                });

            // Initial update
            updateParetoFront();
            updateBurritoVisualization();

            console.log("UI elements enabled");
        }

        const ingredientColors = {
            "Tortilla": "#a6cee3",
            "Beef": "#1f78b4",
            "Chicken": "#b2df8a",
            "Pork": "#33a02c",
            "Cheese": "#33a02c",
            "Sour Cream": "#ff8ab7",
            "Rice": "#fdbf6f",
            "Beans": "#ff7f00",
            "Lettuce": "#cab2d6",
            "Onions": "#6a3d9a",
            "Tomato": "#e31a1c",
            "Avocado": "#b15928"
        };

        // Helper function to validate data structure
        function validateIngredientData(data) {
            if (!data || typeof data !== 'object') {
                console.error('Invalid ingredient data structure');
                return false;
            }

            // Check first level (importing countries)
            for (const country in data) {
                if (!data[country] || typeof data[country] !== 'object') {
                    console.error(`Invalid data structure for country: ${country}`);
                    return false;
                }

                // Check second level (ingredients)
                for (const ingredient in data[country]) {
                    if (!data[country][ingredient] || typeof data[country][ingredient] !== 'object') {
                        console.error(`Invalid data structure for ingredient: ${ingredient} in ${country}`);
                        return false;
                    }

                    // Check third level (source countries)
                    for (const sourceCountry in data[country][ingredient]) {
                        const sourceData = data[country][ingredient][sourceCountry];
                        if (!sourceData ||
                            typeof sourceData.cost !== 'number' ||
                            typeof sourceData.impact !== 'number') {
                            console.error(`Invalid data for ${ingredient} from ${sourceCountry} in ${country}`);
                            return false;
                        }
                    }
                }
            }
            return true;
        }

      // Modified initialization function with proper data validation
        function initializePopulation(selectedIngredients, importingCountry, budget, populationSize = 50) {
            const population = [];
            let attempts = 0;
            const maxAttempts = populationSize * 10;

            // console.log(`Initializing population for ${selectedIngredients.length} ingredients with budget ${budget}`);

            // Validate ingredient data exists for importing country
            if (!ingredientData[importingCountry]) {
                console.error(`No data found for importing country: ${importingCountry}`);
                return population;
            }

            while (population.length < populationSize && attempts < maxAttempts) {
                const individual = { solution: {} };
                let validIndividual = true;
                let currentCost = 0;

                for (const ingredient of selectedIngredients) {
                    // Check if ingredient data exists
                    const ingredientOptions = ingredientData[importingCountry][ingredient];
                    if (!ingredientOptions) {
                        console.warn(`No data found for ${ingredient} in ${importingCountry}`);
                        validIndividual = false;
                        break;
                    }

                    // Get available source countries with valid cost data
                    const sourceOptions = Object.entries(ingredientOptions)
                        .filter(([_, data]) => (
                            data &&
                            typeof data.cost === 'number' &&
                            !isNaN(data.cost) &&
                            data.cost + currentCost <= budget
                        ))
                        .map(([country, data]) => ({
                            country,
                            cost: data.cost
                        }));

                    if (sourceOptions.length === 0) {
                        console.warn(`No affordable sources found for ${ingredient}`);
                        validIndividual = false;
                        break;
                    }

                    // Select random source country from affordable options
                    const selectedOption = sourceOptions[Math.floor(Math.random() * sourceOptions.length)];
                    individual.solution[ingredient] = selectedOption.country;
                    currentCost += selectedOption.cost;
                }

                if (validIndividual) {
                    calculateCostAndImpact(individual, importingCountry);
                    if (individual.cost !== undefined && individual.cost <= budget) {
                        population.push(individual);
                        // console.log(`Added valid individual with cost: ${individual.cost}`);
                    }
                }

                attempts++;
            }

            console.log(`Generated ${population.length} valid individuals after ${attempts} attempts`);
            return population;
        }

        // Calculate cost and impact
        function calculateCostAndImpact(individual, importingCountry) {
            let totalCost = 0;
            let totalImpact = 0;
            let validIndividual = true;

            for (const [ingredient, country] of Object.entries(individual.solution)) {
                const data = ingredientData[importingCountry]?.[ingredient]?.[country];
                if (data) {
                    totalCost += data.cost;
                    totalImpact += data.impact;
                } else {
                    console.warn(`Invalid data for ${ingredient} from ${country}`);
                    validIndividual = false;
                    break;
                }
            }

            if (validIndividual) {
                individual.cost = totalCost;
                individual.impact = totalImpact;
            } else {
                individual.cost = undefined;
                individual.impact = undefined;
            }
        }

        // Non-dominated sorting
        function nonDominatedSorting(population) {
            let fronts = [[]];
            population.forEach(p => {
                p.dominatedCount = 0;
                p.dominatedSet = [];
                population.forEach(q => {
                    if ((q.cost <= p.cost && q.impact <= p.impact) && (q.cost < p.cost || q.impact < p.impact)) {
                        p.dominatedCount += 1;
                    } else if ((p.cost <= q.cost && p.impact <= q.impact) && (p.cost < q.cost || p.impact < q.impact)) {
                        p.dominatedSet.push(q);
                    }
                });
                if (p.dominatedCount === 0) {
                    p.rank = 0;
                    fronts[0].push(p);
                }
            });
            let i = 0;
            while (fronts[i].length > 0) {
                const nextFront = [];
                fronts[i].forEach(p => {
                    p.dominatedSet.forEach(q => {
                        q.dominatedCount -= 1;
                        if (q.dominatedCount === 0) {
                            q.rank = i + 1;
                            nextFront.push(q);
                        }
                    });
                });
                i++;
                fronts.push(nextFront);
            }
            return fronts.slice(0, -1);
        }

        // Calculate crowding distance
        function calculateCrowdingDistance(front) {
            const l = front.length;
            if (l === 0) return;

            front.forEach(ind => ind.crowdingDistance = 0);
            ['cost', 'impact'].forEach(key => {
                front.sort((a, b) => a[key] - b[key]);
                front[0].crowdingDistance = front[l - 1].crowdingDistance = Infinity;
                const min = front[0][key];
                const max = front[l - 1][key];
                for (let i = 1; i < l - 1; i++) {
                    front[i].crowdingDistance += (front[i + 1][key] - front[i - 1][key]) / (max - min || 1); // Avoid division by zero
                }
            });
        }

        // Selection using tournament selection
        function selection(population, numToSelect) {
            const selected = [];
            while (selected.length < numToSelect) {
                const tournament = [];
                const tournamentSize = 2;
                for (let i = 0; i < tournamentSize; i++) {
                    const randomIndividual = population[Math.floor(Math.random() * population.length)];
                    tournament.push(randomIndividual);
                }
                tournament.sort((a, b) => {
                    if (a.rank !== b.rank) {
                        return a.rank - b.rank;
                    } else {
                        return b.crowdingDistance - a.crowdingDistance;
                    }
                });
                selected.push(tournament[0]);
            }
            return selected;
        }

        // Crossover operator
        function crossover(parent1, parent2) {
            const child = { solution: {} };
            for (const ingredient in parent1.solution) {
                child.solution[ingredient] = Math.random() < 0.5 ? parent1.solution[ingredient] : parent2.solution[ingredient];
            }
            return child;
        }

        // Mutation operator
        function mutation(individual, importingCountry, mutationRate = 0.1) {
            for (const ingredient in individual.solution) {
                if (Math.random() < mutationRate) {
                    const countries = Object.keys(ingredientData[importingCountry][ingredient]);
                    individual.solution[ingredient] = countries[Math.floor(Math.random() * countries.length)];
                }
            }
            return individual;
        }

        // Run NSGA-II optimization
        function runNSGA2Optimization(selectedIngredients, importingCountry, budget) {
            console.log(`Starting optimization with budget: ${budget}`);

            // Validate inputs
            if (!ingredientData[importingCountry]) {
                throw new Error(`Invalid home country: ${importingCountry}`);
            }

            // Calculate minimum possible cost before attempting optimization
            let minPossibleCost = 0;
            let debugCosts = {};

            for (const ingredient of selectedIngredients) {
                if (ingredientData[importingCountry][ingredient]) {
                    const costs = Object.values(ingredientData[importingCountry][ingredient])
                        .map(data => data.cost)
                        .filter(cost => typeof cost === 'number' && !isNaN(cost));

                    if (costs.length > 0) {
                        const minCost = Math.min(...costs);
                        minPossibleCost += minCost;
                        debugCosts[ingredient] = {
                            allCosts: costs,
                            minCost: minCost
                        };
                    } else {
                        console.error(`No valid costs found for ${ingredient} in ${importingCountry}`);
                    }
                } else {
                    console.error(`No data found for ${ingredient} in ${importingCountry}`);
                }
            }

            console.log('Debug costs for each ingredient:', debugCosts);
            console.log(`Total minimum possible cost: ${minPossibleCost}`);

            // Initial population
            let population = initializePopulation(selectedIngredients, importingCountry, budget);

            if (population.length === 0) {
                console.warn("Could not generate initial population within budget");
                return [];
            }

            const generations = 50;
            const populationSize = population.length;

            // Main NSGA-II loop
            for (let generation = 0; generation < generations; generation++) {
                // console.log(`Generation ${generation + 1}`);

                // Selection
                const matingPool = selection(population, populationSize);

                // Create new population
                let offspring = [];
                while (offspring.length < populationSize) {
                    const parent1 = matingPool[Math.floor(Math.random() * matingPool.length)];
                    const parent2 = matingPool[Math.floor(Math.random() * matingPool.length)];

                    let child = crossover(parent1, parent2);
                    child = mutation(child, importingCountry);

                    calculateCostAndImpact(child, importingCountry);

                    if (child.cost !== undefined && child.cost <= budget) {
                        offspring.push(child);
                    }
                }

                // Combine populations
                population = [...population, ...offspring];

                // Non-dominated sorting
                const fronts = nonDominatedSorting(population);

                // Select next generation
                population = [];
                for (const front of fronts) {
                    if (population.length + front.length <= populationSize) {
                        population.push(...front);
                    } else {
                        calculateCrowdingDistance(front);
                        front.sort((a, b) => b.crowdingDistance - a.crowdingDistance);
                        population.push(...front.slice(0, populationSize - population.length));
                        break;
                    }
                }

                // console.log(`Population size after generation ${generation + 1}: ${population.length}`);
            }

            // Get final Pareto front
            const finalFronts = nonDominatedSorting(population);
            const paretoFront = finalFronts[0] || [];

            console.log(`Final Pareto front size: ${paretoFront.length}`);
            return paretoFront;
        }

        // Select the optimal solution based on weights
        function selectOptimalSolution(paretoFront, costWeight, impactWeight) {
            // Calculate min and max for normalization
            const minCost = d3.min(paretoFront, d => d.cost);
            const maxCost = d3.max(paretoFront, d => d.cost);
            const minImpact = d3.min(paretoFront, d => d.impact);
            const maxImpact = d3.max(paretoFront, d => d.impact);

            let bestSolution = null;
            let bestScore = Infinity;

            paretoFront.forEach(solution => {
                // Normalize cost and impact
                const normalizedCost = (solution.cost - minCost) / (maxCost - minCost || 1);
                const normalizedImpact = (solution.impact - minImpact) / (maxImpact - minImpact || 1);

                // Invert costWeight since slider movement should be opposite
                // When slider is at 0 (far left, "Low Cost"), costWeight should be 1
                // When slider is at 1 (far right, "Low Impact"), costWeight should be 0
                const adjustedCostWeight = 1 - costWeight;
                const adjustedImpactWeight = costWeight;  // This becomes the opposite of costWeight

                // Calculate weighted score using normalized values
                const weightedScore = normalizedCost * adjustedCostWeight + normalizedImpact * adjustedImpactWeight;

                // console.log(`Solution: ${JSON.stringify(solution)}, Weighted Score: ${weightedScore}`);

                if (weightedScore < bestScore) {
                    bestScore = weightedScore;
                    bestSolution = solution;
                }
            });

            console.log("Selected optimal solution:", bestSolution);
            return bestSolution;
        }

        // Display Pareto Front with hover tooltips and highlight the optimal solution
        function displayParetoFront(paretoFront, finalSolution) {
            const svg = d3.select("#pareto-chart");
            const svgWidth = +svg.attr("width");
            const svgHeight = +svg.attr("height");
            const margin = { top: 10, right: 20, bottom: 30, left: 40 };
            const width = svgWidth - margin.left - margin.right;
            const height = svgHeight - margin.top - margin.bottom;

            svg.selectAll("*").remove();

            if (paretoFront.length === 0) return;

            // Filter out individuals with undefined cost or impact
            paretoFront = paretoFront.filter(d => d.cost !== undefined && d.impact !== undefined);

            const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
            const x = d3.scaleLinear().range([0, width]).domain([0, d3.max(paretoFront, d => d.cost) * 1.1]);
            const y = d3.scaleLinear().range([height, 0]).domain([0, d3.max(paretoFront, d => d.impact) * 1.1]);

            // Axes
            g.append("g").attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x).ticks(5))
                .append("text")
                .attr("x", width / 2)
                .attr("y", 30)
                .attr("fill", "black")
                .style("text-anchor", "middle")
                .text("Cost");

            g.append("g").call(d3.axisLeft(y).ticks(5))
                .append("text")
                .attr("x", -height / 2)
                .attr("y", -30)
                .attr("fill", "black")
                .attr("transform", "rotate(-90)")
                .style("text-anchor", "middle")
                .text("Impact");

            // Select the tooltip div
            const tooltip = d3.select(".tooltip");

            // Dots with tooltip events - Updated event handling
            g.selectAll("circle.pareto-point")
                .data(paretoFront)
                .enter().append("circle")
                .attr("class", "pareto-point")
                .attr("cx", d => x(d.cost))
                .attr("cy", d => y(d.impact))
                .attr("r", 5)
                .attr("fill", "blue")
                .on("mouseover", function(d) {
                    const [mouseX, mouseY] = d3.mouse(document.body);
                    const costText = d.cost !== undefined ? d.cost.toFixed(2) : "N/A";
                    const impactText = d.impact !== undefined ? d.impact.toFixed(2) : "N/A";
                    tooltip.html(`Cost: $${costText}<br>Impact: ${impactText}`)
                        .style("left", (mouseX + 15) + "px")
                        .style("top", (mouseY + 15) + "px")
                        .style("opacity", 1);
                })
                .on("mousemove", function() {
                    const [mouseX, mouseY] = d3.mouse(document.body);
                    tooltip.style("left", (mouseX + 15) + "px")
                           .style("top", (mouseY + 15) + "px");
                })
                .on("mouseout", function() {
                    tooltip.style("opacity", 0);
                });

            // Highlight the optimal solution
            if (finalSolution) {
                const optimalX = x(finalSolution.cost);
                const optimalY = y(finalSolution.impact);

                // Append the optimal point with updated event handling
                g.append("circle")
                    .attr("class", "optimal-point")
                    .attr("cx", optimalX)
                    .attr("cy", optimalY)
                    .attr("r", 7)
                    .attr("fill", "red")
                    .attr("stroke", "black")
                    .attr("stroke-width", 1.5)
                    .on("mouseover", function() {
                        const [mouseX, mouseY] = d3.mouse(document.body);
                        tooltip.html(`Optimal Solution<br>Cost: $${finalSolution.cost.toFixed(2)}<br>Impact: ${finalSolution.impact.toFixed(2)}`)
                            .style("left", (mouseX + 15) + "px")
                            .style("top", (mouseY + 15) + "px")
                            .style("opacity", 1);
                    })
                    .on("mousemove", function() {
                        const [mouseX, mouseY] = d3.mouse(document.body);
                        tooltip.style("left", (mouseX + 15) + "px")
                               .style("top", (mouseY + 15) + "px");
                    })
                    .on("mouseout", function() {
                        tooltip.style("opacity", 0);
                    });

                // Append label with cost and impact
                g.append("text")
                    .attr("class", "optimal-label")
                    .attr("x", optimalX)
                    .attr("y", optimalY + 15)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "10px")
                    .attr("fill", "black")
                    .append("tspan")
                        .attr("x", optimalX)
                        .attr("y", optimalY + 25)
                        .text(`Cost: $${finalSolution.cost.toFixed(2)}`)
                    .append("tspan")
                        .attr("x", optimalX)
                        .attr("y", optimalY + 40)
                        .text(`Impact: ${finalSolution.impact.toFixed(2)}`);
            }
        }
        // Display Solution Info
        function displaySolutionInfo(finalSolution) {
            const totalCost = finalSolution.cost.toFixed(2);
            const totalImpact = finalSolution.impact.toFixed(2);
            const countries = Object.values(finalSolution.solution);
            const uniqueCountries = [...new Set(countries)];
            const numberOfCountries = uniqueCountries.length;

            const solutionInfoDiv = d3.select("#solution-info");
            solutionInfoDiv.html(
                `<p>Total Cost: $${totalCost} | Total Emission Score: ${totalImpact} | Number of Countries: ${numberOfCountries}</p>`
            );
        }

        // Display Map
        function displayMap(finalSolution, importingCountry) {
            const svg = d3.select("#country-map");

            svg.selectAll("*").remove();

            if (!finalSolution) {
                console.log("No valid solution, clearing map.");
                return;
            }

            const width = +svg.attr("width");
            const height = +svg.attr("height");
            //const projection = d3.geoMercator().scale(130).translate([width / 2.2, height / 1.5]);

            // Equal Earth projection - better area representation
            const projection = d3.geoRobinson()
                .scale(170)
                .center([0, 15])
                .translate([width / 2, height / 2]);

            const path = d3.geoPath().projection(projection);

            d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson").then(function (data) {
                svg.append("g")
                    .selectAll("path")
                    .data(data.features)
                    .enter().append("path")
                    .attr("d", path)
                    .attr("fill", "lightgray")
                    .attr("stroke", "white");

               const countryNameMapping = {
                    "Australia": "Australia",
                    "Brazil": "Brazil",
                    "Bolivia": "Bolivia",
                    "Canada": "Canada",
                    "Cabo Verde": "Cape Verde",
                    "Colombia": "Colombia",
                    "Czechia": "Czech Republic",  // GeoJSON might use older name
                    "Guyana": "Guyana",
                    "Luxembourg": "Luxembourg",
                    "Madagascar": "Madagascar",
                    "Mauritius": "Mauritius",
                    "Mexico": "Mexico",
                    "Romania": "Romania",
                    "Mozambique": "Mozambique",
                    "South Africa": "South Africa",
                    "Serbia": "Serbia",
                    "Slovakia": "Slovakia",
                    "Uruguay": "Uruguay",
                    "Turkey": "Turkey",
                    "Zambia": "Zambia",
                    "Argentina": "Argentina",
                    "Chile": "Chile",
                    "Iceland": "Iceland",
                    "Paraguay": "Paraguay",
                    "Philippines": "Philippines",
                    "Tanzania": "Tanzania",
                    "USA": "United States of America"  // GeoJSON uses full name
                };

                // Get the actual country name
                const importingCountryName = countryNameMapping[importingCountry];

                if (importingCountryName) {
                    // Highlight the importing country's border
                    svg.selectAll("path")
                        .filter(d => d.properties && d.properties.name === importingCountryName)
                        .style("stroke", "black")
                        .style("stroke-width", 3);
                }

                console.log("Mapping countries for each ingredient:", finalSolution.solution);

                let countryAngles = {};
                const angleStep = Math.PI / 4; // 45 degrees for spacing

                Object.keys(finalSolution.solution).forEach(ingredient => {
                    const country = finalSolution.solution[ingredient];
                    const data = ingredientData[importingCountry][ingredient][country];
                    const coords = projection([data.Longitude, data.Latitude]);

                    // Initialize angle for the country if not already
                    if (!countryAngles[country]) {
                        countryAngles[country] = 0;
                    }

                    const angle = countryAngles[country];
                    const radius = 120; // Increased radius for better spacing
                    const labelX = coords[0] + radius * Math.cos(angle);
                    const labelY = coords[1] + radius * Math.sin(angle);

                    // Update angle for next label from the same country
                    countryAngles[country] += angleStep;

                    // Replace the existing label creation code with this:
                    // First create a group for the label and its background
                    const labelGroup = svg.append("g")
                        .attr("class", "label-group")
                        .attr("transform", `translate(${labelX},${labelY})`);

                    // Calculate text metrics for the box
                    const labelHeight = 45; // Height to accommodate 4 lines of text
                    const labelWidth = 120;  // Approximate width, adjust as needed
                    const padding = 6;  // Padding around text

                    // Add the background rectangle
                    labelGroup.append("rect")
                        .attr("x", -padding)  // Offset by padding
                        .attr("y", -padding)  // Adjust to align with first line of text
                        .attr("width", labelWidth+ 2*padding)
                        .attr("height", labelHeight+3*padding)
                        .attr("fill",ingredientColors[ingredient])
                        .attr("stroke", "#666")
                        .attr("stroke-width", 1)
                        .attr("rx", 4)  // Rounded corners
                        .style("opacity", 0.7);

                    // Add the text elements
                    const label = labelGroup.append("text")
                        .attr("class", "label")
                        .style("fill", "black")
                        .style("font-size", "12px");

                    // Add the text lines
                    label.append("tspan")
                        .attr("x", 0)
                        .attr("y", padding)
                        .text(country)
                        .style("font-weight", "bold");

                    label.append("tspan")
                        .attr("x", 0)
                        .attr("y", padding+15)
                        .text(`Ingredient: ${ingredient}`);

                    label.append("tspan")
                        .attr("x", 0)
                        .attr("y", padding+30)
                        .text(`Cost: $${data.cost.toFixed(2)}`);

                    label.append("tspan")
                        .attr("x", 0)
                        .attr("y", padding+45)
                        .text(`Impact: ${data.impact.toFixed(2)}`);

                    // Update the connecting line endpoint to connect to the group
                    svg.append("line")
                        .attr("class", "line")
                        .attr("x1", coords[0])
                        .attr("y1", coords[1])
                        .attr("x2", labelX)
                        .attr("y2", labelY)
                        .attr("stroke", ingredientColors[ingredient])
                        .attr("stroke-width", 2);

                    // Highlight the country on the map
                    svg.selectAll("path")
                        .filter(d => d.properties && d.properties.name === country)
                        .style("fill", ingredientColors[ingredient])

                });

                // Adjust label positioning to prevent overlapping
                preventLabelOverlap(svg, "text.label");
                createActiveLegend(finalSolution, importingCountry);
            });
        }

        function handleBurritoConfirm(isConfirmed) {
            const message = isConfirmed
                ? "Great choice! Your burrito combination has been confirmed."
                : "No problem! Feel free to explore more selections to find your perfect burrito.";
            alert(message);
        }

        // Function to prevent label overlapping
        function preventLabelOverlap(svg, labelClass) {
            const labels = svg.selectAll(labelClass).nodes();
            const padding = 15; // Minimum distance between labels

            for (let i = 0; i < labels.length; i++) {
                for (let j = i + 1; j < labels.length; j++) {
                    const labelA = labels[i].getBBox();
                    const labelB = labels[j].getBBox();

                    if (isOverlapping(labelA, labelB, padding)) {
                        // Shift labelB down by padding
                        const currentY = parseFloat(d3.select(labels[j]).attr("y")) + padding;
                        d3.select(labels[j]).attr("y", currentY);
                    }
                }
            }
        }

        // Alternative legend creation that only shows active ingredients
        function createActiveLegend(finalSolution, importingCountry) {
            // Remove any existing legend
            d3.select("#map-legend").selectAll("*").remove();
            console.log("Selected country in Legend:", importingCountry);
            // Get active ingredients
            const activeIngredients = Object.keys(finalSolution.solution);

            // Create filtered colors object
            const activeColors = {};
            activeIngredients.forEach(ingredient => {
                activeColors[ingredient] = ingredientColors[ingredient];
            });

            // Get the existing legend container
            const legendContainer = d3.select("#map-legend");

            // Add legend title
            legendContainer.append("div")
                .attr("class", "legend-title")
                .text("Home Country");

            // Create a section for the importing country
            const importingItem = legendContainer.append("div")
                .attr("class", "legend-item");

            // Add color box for importing country
            importingItem.append("div")
                .attr("class", "color-box")
                .style("background-color", "lightgray")
                .style("border", "3px solid black"); // Thick black outline

            // Add importing country label
            importingItem.append("span")
                .text(importingCountry);

            // Add a separator
            legendContainer.append("hr")
                .style("margin", "10px 0")
                .style("border", "1px solid #ccc");

            // Add ingredients section title
            legendContainer.append("div")
                .attr("class", "legend-title")
                .style("margin-top", "10px")
                .text("Ingredients");

            // Add legend items for ingredients
            const legendItems = legendContainer.selectAll(".ingredient-legend-item")
                .data(Object.entries(activeColors))
                .enter()
                .append("div")
                .attr("class", "legend-item");

            // Add color boxes
            legendItems.append("div")
                .attr("class", "color-box")
                .style("background-color", d => d[1]);

            // Add ingredient names
            legendItems.append("span")
                .text(d => d[0]);
        }
        function updateBurritoVisualization() {
            const burritoPreview = document.getElementById('burrito-preview');
            burritoPreview.innerHTML = ''; // Clear existing images

            // Order of ingredients from bottom to top
            const ingredientOrder = [
                'tortilla',
                'lettuce',
                'rice',
                'beans',
                'beef',
                'chicken',
                'pork',
                'cheese',
                'onions',
                'tomatoes',
                'sour-cream',
                'avocado'
            ];

            // Add images for checked ingredients in order
            ingredientOrder.forEach((ingredient, index) => {
                const checkbox = document.getElementById(ingredient);
                if (checkbox && checkbox.checked) {
                    const img = document.createElement('img');
                    img.src = `images2/${ingredient}.png`;
                    img.alt = ingredient;
                    img.style.zIndex = index;
                    burritoPreview.appendChild(img);
                }
            });

            // Show placeholder text if no ingredients selected
            if (burritoPreview.children.length === 0) {
                const placeholder = document.createElement('div');
                placeholder.style.position = 'absolute';
                placeholder.style.top = '50%';
                placeholder.style.left = '50%';
                placeholder.style.transform = 'translate(-50%, -50%)';
                placeholder.style.color = '#666';
                placeholder.textContent = 'Select ingredients to build your burrito';
                burritoPreview.appendChild(placeholder);
            }
        }

        // Helper function to determine if two bounding boxes overlap
        function isOverlapping(bboxA, bboxB, padding) {
            return !(bboxA.x + bboxA.width + padding < bboxB.x ||
                     bboxA.x > bboxB.x + bboxB.width + padding ||
                     bboxA.y + bboxA.height + padding < bboxB.y ||
                     bboxA.y > bboxB.y + bboxB.height + padding);
        }

        function updateParetoFront() {
            if (!ingredientData) {
                console.warn("Ingredient data not yet loaded");
                return;
            }

            // Get selected ingredients, ensuring tortilla is always included
            const selectedCheckboxes = Array.from(document.querySelectorAll("input[type=checkbox]:checked")).map(el => el.value);
            const selectedIngredients = [...selectedCheckboxes];
            if (!selectedIngredients.includes("Tortilla")) {
                selectedIngredients.push("Tortilla");
            }


            const budgetInput = d3.select("#budget-input").node();
            const budget = +budgetInput.value;

            if (isNaN(budget) || budget <= 0) {
                alert("Please enter a valid budget.");
                return;
            }

            const importingCountry = d3.select("#importing-country").node().value;
            console.log("Selected country:", importingCountry);
            console.log("Selected ingredients:", selectedIngredients);
            console.log("Budget:", budget);

            if (!ingredientData[importingCountry]) {
                console.error(`Data not found for country: ${importingCountry}`);
                alert(`No data available for ${importingCountry}`);
                return;
            }

            const costWeight = +d3.select("#weight-slider").property("value") / 100;
            const impactWeight = 1 - costWeight;

            const paretoFront = runNSGA2Optimization(selectedIngredients, importingCountry, budget);

            if (paretoFront.length === 0) {
                d3.select("#pareto-chart").selectAll("*").remove();
                d3.select("#country-map").selectAll("*").remove();
                d3.select("#solution-info").html("");
                d3.select("#map-legend").remove();
                alert("No valid solution found within the budget.");
                return;
            }

            const finalSolution = selectOptimalSolution(paretoFront, costWeight, impactWeight);

            displayParetoFront(paretoFront, finalSolution);

            if (finalSolution) {
                displaySolutionInfo(finalSolution);
                displayMap(finalSolution, importingCountry);
            }
        }

    </script>
</body>
</html>