    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
        <title>NSGA-II Optimization for Burrito Builder</title>
        <script src="https://d3js.org/d3.v5.min.js"></script>
        <script src="https://d3js.org/d3-geo-projection.v4.min.js"></script>

        <style>
            /* Global Font Style */
            body {
                font-family: 'Poppins', sans-serif;
                margin: 0;          /* Changed from margin: 20px */
                display: flex;
                flex-direction: column;
                align-items: center;
                width: 100%;
            }

            /* Center the page title */
            h2 {
                text-align: center;
                margin-bottom: 0px;
                width: 100%;
            }

            h2 {
                text-align: center;
                width: 50%;
            }

            /* Country Styling */
            .country { fill: rgb(143, 204, 245); stroke: white; cursor: pointer; }
            .country:hover { fill: lightblue; }

            /* Tooltip Styling */
            .tooltip {
                position: fixed;  /* Change from absolute to fixed */
                background-color: white;
                padding: 10px;
                border-radius: 4px;
                pointer-events: none;
                font-size: 12px;
                color: black;
                opacity: 0;
                transition: opacity 0.3s;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                z-index: 9999;  /* Ensure it's always on top */
                max-width: 200px;
                white-space: pre-line;
                line-height: 1.4;
                text-align: left;
            }

            /* Label and Line Styling */
            .label { font-size: 14px; font-weight: bold; }
            .line { stroke-width: 1.5; }

            /* Map wrapper and content layout */
            .map-wrapper {
                width: 100%;
                box-sizing: border-box;
                margin-top: 20px;
            }

            /* Map container layout */
            #map {
                width: 100%;
                padding: 0;  /* Remove padding that might affect width */
                margin-bottom: 20px;
                box-sizing: border-box;
            }

            /* Update section boxes within map */
            #map .section-box {
                width: 100%;
                margin-bottom: 20px; /* Add space between cost info and map */
                box-sizing: border-box;
            }

            /* Map content container with flexbox */
            .map-content {
                display: flex;
                flex-direction: row;
                gap: 20px;
                margin: 0;
                padding: 0;
                justify-content: flex-start;
                width: 100%;
            }

            .map-container {
                width: 960px;
                flex: 0 0 auto;
                min-width: 0;
                box-sizing: border-box;
            }

            html, body {
                overflow-x: auto;
                min-width: fit-content;
            }

            .axis text{
                font-family: 'Poppins', sans-serif;
                font-size: 12px;
                /*font-weight: bold;*/
            }

            .axis-label {
                font-family: 'Poppins', sans-serif;
                fill: black;
                font-weight: normal;
            }

            /* Layout Styling */
            .form-row {
                display: flex;
                gap: 20px;
                width: 100%;
                box-sizing: border-box;
                margin-bottom: 20px;
            }

            .form-column.left-column,
            .form-column.right-column {
                flex: 1;  /* Make both columns take equal space */
                display: flex;
                flex-direction: column;
                gap: 20px;
                width: 50%;  /* Ensure each column takes exactly half */
            }

            /* New styles for the combined section */
            .preference-visualization-section {
                flex:1;
                display: flex;
                flex-direction: column;
                gap: 15px;
                width: 100%;
                padding: 0;
            }

            .preference-slider {
                width: 100%;
                padding: 40px 40px 20px 40px;
                position: relative
            }

            .visualization-container {
                width: 92%;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            /* Two-column layout container */
            .columns-container {
                display: flex;
                gap: 20px;
                margin-bottom: 20px;
            }

            /* Column styles */
            .left-column, .right-column {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 20px;
            }

            .left-column{
                width:45%;
            }

            .right-column{
                width:55%;
            }

            /* Adjustments for Pareto Front Visualization */
            #pareto-chart {
                width: 100%;
                height: 300px;
                margin: 0 auto;
            }

            /* Highlight Styling for Optimal Solution */
            .optimal-point {
                fill: yellow;
                stroke: black;
                stroke-width: 1px;
            }
            .optimal-label {
                font-size: 12px;
                font-weight: bold;
                fill: black;
                background: white;
            }

            .slider-flex-container {
                display: flex;
                flex-direction: column;
                gap: 15px;
                margin-top: 20px;
            }

            .slider-container {
                width: 92%;
                display: flex;
                align-items: center;
                position: relative;
            }

            .slider-label {
                position: absolute;
                font-size: 16px;
                color: #4a5568;
                text-align: center;
                line-height: 1.2;
                font-weight: bold;
                pointer-events: none; /* Prevent labels from interfering with slider */
            }

            .slider-label.left {
                left: 0;
                text-align: right;
            }

            .slider-label.right {
                right: 0;
                text-align: left;
            }

            /* Make the slider track match the chart width */
            #weight-slider.styled-slider {
                width: 100%;
                margin-left: 55px;
                margin-right: 130px;
                -webkit-appearance: none;
                appearance: none;
                height: 4px;
                background: #e2e8f0;
                border-radius: 2px;
                outline: none;
            }

            /* Chrome/Safari specific styles */
            .styled-slider::-webkit-slider-runnable-track {
                width: 100%;
                height: 4px;
                background: white;
                border: 1px solid #cbd5e0;
                border-radius: 2px;
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
            }

            .styled-slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 18px;
                height: 18px;
                border-radius: 50%;
                background: 4299e1;
                border: 2px solid #2b6cb0;
                cursor: pointer;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                transition: all 0.2s ease;
                margin-top: -7px;
            }


            /* Section label styling */
            .section-label {
                color: black;
                font-weight: bold;
                margin-bottom: 10px;
                display: block;
            }

            /* Add these new styles for the slider appearance */
            input[type="range"] {
                -webkit-appearance: none;
                width: 200px;
                height: 2px;
                background: #d3d3d3;
                border: none;
                border-radius: 2px;
            }

            /* Style the slider thumb */
            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 15px;
                height: 15px;
                border-radius: 50%;
                background: #333;
                cursor: pointer;
                border: none;
            }

            input[type="range"]::-moz-range-thumb {
                width: 15px;
                height: 15px;
                border-radius: 50%;
                background: #333;
                cursor: pointer;
                border: none;
            }

            /* Remove focus outline */
            input[type="range"]:focus {
                outline: none;
            }

            /* Map Header Styling */
            .map-header {
                display: block;  /* Ensure header doesn't affect flow */
                width: 100%;
                margin:0 0 20px 0;
                padding:0;
            }

            .flex.justify-between.items-center.w-full {
                display: flex;
                position: relative;
                z-index: 1;
                justify-content: flex-start;  /* Change from between to flex-start */
                align-items: flex-start;      /* Change from center to flex-start */
                width: 100%;
            }

            #solution-info {
                max-width: none;
                font-size: 20px;
                font-weight: bold;
                color: black;
                text-align: left;
                margin: 0;
                padding: 0;
            }

            .importing-country{
                color: black;
                font-weight: lighter;
            }

            /* Section Label Styling */
            .section-label {
                color: black;
                font-weight: bold;
                margin-right: auto;
                white-space: nowrap;
                text-anchor: middle;
                font-size: 20px;
            }

            .section-sublabel{
                color: darkgray;
                font-weight: normal;
                margin-right: auto;
                white-space: nowrap;
            }

            /* Legend Container with responsive positioning */
            .legend-container {
                flex: 0 0 150px;
                background-color: rgba(255, 255, 255, 0.9);
                padding: 15px;
                border-radius: 5px;
                border: 1px solid #ccc;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                height: fit-content; /* Make height adapt to content */
                min-height: min-content; /* Ensure it doesn't collapse */
                position: sticky;
                margin: 0;
                box-shadow: border-box;
                top:20px
            }

            .legend-title {
                font-weight: bold;
                margin-bottom: 10px;
                font-size: 14px;
                border-bottom: 1px solid #ccc;
                padding-bottom: 5px;
            }

            .legend-item {
                display: flex;
                align-items: center;
                margin: 5px 0;
                font-size: 12px;
                padding: 2px 0;
            }

            #country-map {
                width: 100%;
                height: auto;
                max-width: 960px;
            }

            /* Map SVG dimensions */
            #map svg {
                width: 100%;
                height: 500px;
            }

            .color-box {
                width: 15px;
                height: 15px;
                margin-right: 8px;
                border: 1px solid #666;
            }


            .map-header {
                display: block;
                width: 100%;
                margin: 0;        /* Remove auto margins */
                padding: 0;       /* Remove padding */
            }

            .confirmation-section {
                width: 100%;
                margin: 10px 0 0 0;
                padding: 0;
                display: flex;
                justify-content: flex-start;
            }

            .confirmation-content {
                display: flex;
                align-items: center;
                gap: 20px;
                margin: 0;
                padding: 0;
            }

            .confirmation-text {
                font-size: 1.2rem;
                font-weight: 600;
                color: #2d3748;
            }

            .confirmation-buttons {
                display: flex;
                gap: 15px;
            }

            .confirm-yes, .confirm-no {
                padding: 8px 25px;
                border: none;
                border-radius: 20px;
                cursor: pointer;
                font-size: 1rem;
                font-weight: 500;
                transition: all 0.3s ease;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            }

            .confirm-yes {
                background: linear-gradient(45deg, #4CAF50, #45a049);
                color: white;
            }

            .confirm-no {
                background: linear-gradient(45deg, #ff9b76, #ff7f50);
                color: white;
            }

            .confirm-yes:hover, .confirm-no:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            }

            /* Update success and adjust popups to be centered */
            .success-popup, .adjust-popup {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 30px;
                border-radius: 15px;
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
                text-align: center;
                z-index: 1001;
                animation: popIn 0.5s ease;
            }

            @keyframes popIn {
                0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            }

            .popup-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.3s;
                z-index: 1000;
            }

            .popup-overlay.show {
                opacity: 1;
                visibility: visible;
            }

            /* Update the popup positioning to be centered */
            .popup-confirm {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) scale(0.95);
                width: 400px;
            }

            .popup-confirm.show {
                transform: translate(-50%, -50%) scale(1);
            }

            .confirmation-section button:hover {
                opacity: 0.9;
            }

            .flex-container {
                flex:1;
                display: flex;
                gap: 2rem;
            }

            .flex-column {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            /* Update flex container styles */
            .flex-column.justify-between.items-center.w-full {
                display: flex;
                position: relative;
                z-index: 1;
                justify-content: flex-start;
                align-items: flex-start;
                width: 100%;
                margin-bottom: 20px;  /* Consistent spacing */
            }

            .ingredient-list {
                flex: 1;
            }

            .burrito-preview {
                flex: 1;
                width: 256px;
                height: 256px;
                position: relative;
            }

            .burrito-preview img {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                object-fit: contain;
            }

            /* Add new splash screen styles */
            .splash-screen {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: linear-gradient(135deg, #f5d794, #ff9b76);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 9999;
                transition: opacity 0.5s ease-in-out;
            }

            .splash-content {
                text-align: center;
                color: #333;
                padding: 2rem;
                max-width: 600px;
            }

            .splash-title {
                font-size: 3rem;
                margin-top: 20px;
                font-weight: bold;
                color: #2d3748;
            }

            .splash-description {
                font-size: 1.2rem;
                margin-bottom: 2rem;
                line-height: 1.6;
                color: #4a5568;
            }

            .start-button {
                padding: 1rem 2rem;
                font-size: 1.2rem;
                background-color: #4a5568;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                transition: transform 0.2s, background-color 0.2s;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }

            .start-button:hover {
                background-color: #2d3748;
                transform: translateY(-2px);
            }

            .hidden {
                opacity: 0;
                pointer-events: none;
            }

            /* Center the main content container */
            .main-content {
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 40px;
                width: 100%;
                box-sizing: border-box;
            }

            .main-content.visible {
                opacity: 1;
            }

            .subtitle {
                font-size: 1rem;
                margin-bottom: 2rem;
                /*line-height: 1.6;*/
                color: #4a5568;
            }

            #confirmBurrito {
                background: linear-gradient(45deg, #FF6B6B, #FFE66D);
                color: white;
                font-size: 1.2rem;
                padding: 12px 30px;
                border: none;
                border-radius: 25px;
                cursor: pointer;
                transition: all 0.3s ease;
                font-weight: bold;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                position: relative;
                overflow: hidden;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            #confirmBurrito:before {
                content: "ðŸŒ¯";
                font-size: 1.4rem;
            }

            #confirmBurrito:hover {
                transform: translateY(-3px);
                box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
                background: linear-gradient(45deg, #FF8787, #FFF3A3);
            }

            #confirmBurrito:active {
                transform: translateY(1px);
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            }

            @keyframes bounce {
                0%, 100% { transform: translateY(0); }
                50% { transform: translateY(-5px); }
            }

            #confirmBurrito:hover:before {
                animation: bounce 1s infinite;
            }

            .popup-confirm {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) scale(0.95);  /* Fixed typo here */
                background: white;
                padding: 30px;
                border-radius: 15px;
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
                z-index: 1000;
                opacity: 0;
                visibility: hidden;
                transition: all 0.3s ease;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                width: 350px;
                text-align: center;
                border: 3px solid #FFD700;
                background: linear-gradient(145deg, #ffffff, #f5f5f5);
            }

            .popup-confirm.show {
                opacity: 1;
                visibility: visible;
                transform: translate(-50%, -50%) scale(1);
            }

            .popup-content {
                width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                text-align: center;
            }

            .popup-emoji {
                font-size: 48px;
                margin-bottom: 15px;
                animation: bounce 1s infinite;
            }

            @keyframes bounce {
                0%, 100% { transform: translateY(0); }
                50% { transform: translateY(-10px); }
            }

            .popup-title {
                font-size: 1.4em;
                color: #2d3748;
                margin-bottom: 25px;
                font-weight: 600;
                width: 100%;
                text-align:center;
            }

            .popup-buttons {
                display: flex;
                justify-content: center;
                gap: 15px;
                margin-top: 20px;
            }

            .popup-button {
                padding: 12px 24px;
                border: none;
                border-radius: 25px;
                cursor: pointer;
                font-size: 16px;
                font-weight: 600;
                transition: all 0.2s ease;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }

            .popup-button:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            }

            .popup-confirm-btn {
                background: linear-gradient(145deg, #4CAF50, #45a049);
                color: white;
                min-width: 160px;
            }

            .popup-confirm-btn:hover {
                background: linear-gradient(145deg, #45a049, #4CAF50);
            }

            .popup-cancel-btn {
                background: linear-gradient(145deg, #ff9b76, #ff7f50);
                color: white;
                min-width: 160px;
            }

            .popup-cancel-btn:hover {
                background: linear-gradient(145deg, #ff7f50, #ff9b76);
            }
            /* Success Message Styling */
            .success-popup {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 30px;
                border-radius: 15px;
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
                text-align: center;
                z-index: 1001;
                animation: popIn 0.5s ease;
            }

            @keyframes popIn {
                0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            }

            /* Adjustment Message Styling */
            .adjust-popup {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 30px;
                border-radius: 15px;
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
                text-align: center;
                z-index: 1001;
                animation: popIn 0.5s ease;
            }

            .no-burrito-popup {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 30px;
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
                z-index: 1000;
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.3s, visibility 0.3s;
                text-align: center;
                max-width: 400px;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            }

            .no-burrito-popup.show {
                opacity: 1;
                visibility: visible;
            }

            .no-burrito-popup .emoji {
                font-size: 48px;
                margin-bottom: 20px;
            }

            .no-burrito-popup .message {
                font-size: 18px;
                color: #2d3748;
                margin-bottom: 25px;
                line-height: 1.4;
            }

            .no-burrito-popup .close-button {
                background-color: #4a5568;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 16px;
                transition: background-color 0.2s;
            }

            .no-burrito-popup .close-button:hover {
                background-color: #2d3748;
            }

            /* Add overlay for background dim */
            .popup-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.3s, visibility 0.3s;
            }

            .popup-overlay.show {
                opacity: 1;
                visibility: visible;
            }

            .section-box {
                width: 100%;
                box-sizing: border-box;
                margin: 0;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                padding: 20px;
                background-color: white;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                /*position: relative; !* Enable positioning context *!*/
                /*display: flex;*/
                /*flex-direction: column;*/
            }

            /* First row sections */
            .section-box.first-row {
                min-height: 100px;
            }

            /* Second row sections */
            .section-box.second-row {
                min-height: 300px;
            }

            .section-box label {
                text-align: left;
                width: 100%;
            }

          #budget-input,
              #update-budget {
                  font-family: Arial, sans-serif;  /* Choose your desired font */
                  font-size: 16px;                 /* Adjust font size */
                  color: #333;                     /* Text color */
              }

              /* Additional styling for the input */
              #budget-input {
                  width: 100px;
                  text-align: right;
                  padding: 5px;
                  border: 1px solid #ccc;          /* Optional: add border */
                  border-radius: 4px;              /* Optional: rounded corners */
              }

              /* Additional styling for the button */
              #update-budget {
                  background-color: white;       /* Button background color */
                  border: 1px solid black;                    /* Remove default border */
                  padding: 8px 12px;               /* Padding inside the button */
                  border-radius: 4px;              /* Rounded corners */
                  cursor: pointer;                 /* Pointer cursor on hover */
                  font-weight: bold;               /* Bold text */
              }

              /* Button hover effect */
              #update-budget:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
              }

                /* Style for the dropdown */
              #importing-country {
                  font-family: Arial, sans-serif; /* Desired font */
                  font-size: 16px;                /* Font size */
                  color: #333;                    /* Text color */
                  width: 100%;                    /* Full width */
                  padding: 5px;                   /* Padding inside the dropdown */
                  border: 1px solid #ccc;         /* Border styling */
                  border-radius: 4px;             /* Rounded corners */
                  background-color: #f9f9f9;      /* Light background color */
                  appearance: none;               /* Removes default dropdown arrow */
              }

              /* Optional styling for dropdown arrow */
              #importing-country::-ms-expand {
                  display: none; /* Removes dropdown arrow for Internet Explorer */
              }

        </style>
    </head>
    <body>
        <h2 class="splash-title">Burrito Builder</h2>
        <h3 class="subtitle">An interactive tool that helps you create the perfect burrito while considering both cost and environmental impact.</h3>

       <div class="splash-screen" id="splashScreen">
            <div class="splash-content">
                <h1 class="splash-title">ðŸŒ¯ Burrito Builder</h1>
                <p class="splash-description">
                    Welcome to the Burrito Builder, an interactive tool that helps you create the perfect burrito while considering both cost and environmental impact. This application uses the NSGA-II optimization algorithm to find the best combination of ingredient sources based on your preferences.
                </p>

            <h3 style="margin: 20px 0 10px 0; color: #2c5282;">How to Use the Interface:</h3>
            <ol style="margin-left: 20px; margin-bottom: 20px;">
                <li><strong>Select Your Location:</strong> Choose your country from the dropdown menu. This will determine the available ingredient sources and their associated costs.</li>
                <li><strong>Set Your Budget:</strong> Enter the maximum amount you're willing to spend on your burrito.</li>
                <li><strong>Choose Ingredients:</strong> Select the ingredients you'd like in your burrito. The tortilla is included by default.</li>
                <li><strong>Adjust Preferences:</strong> Use the slider to balance between cost savings (left) and lower environmental impact (right).</li>
            </ol>

            <p style="margin-bottom: 15px; font-size: 12px">
                The Pareto front visualization shows all optimal solutions, where each point represents a unique combination of ingredient sources. The world map below displays the source countries for your selected burrito configuration, with your location highlighted in black.
            </p>

            <p style="font-style: italic; color: #666; font-size: 12px;">
                Note: The environmental impact score is calculated based on factors such as transportation distance and production methods. Lower scores indicate more environmentally friendly choices.
            </p>
            <button class="start-button" id="startButton">Let's Build! ðŸš€</button>
        </div>
       </div>

        <div class="main-content" id="mainContent">
            <!-- Update the form-row section in the main-content div -->
        <div class="form-row">
            <!-- Left Column -->
            <div class="form-column left-column">
                <div class="section-box">
                    <label class="section-label">Where are you eating your burrito?</label>
                    <label class="section-sublabel">Choose your country from the dropdown</label>
                    <select id="importing-country" style="margin-top:10px;"></select>
                </div>

                <div class="section-box">
                    <label class="section-label">How much do you want to pay for your burrito?</label>
                    <label class="section-sublabel">Type in your highest desired cost in the box below</label>
                    <div style="margin-top: 7px; display: flex; gap: 10px; align-items: center;">
                        $ <input type="number" id="budget-input" name="budget" value="10.00" min="0" step="0.50"
                            onblur="this.value = parseFloat(this.value).toFixed(2);">
                        <button id="update-budget">Update</button>
                    </div>
                </div>

                <div class="section-box">
                    <label class="section-label">What's going in your burrito?</label>
                    <label class="section-sublabel">Choose your ingredients by checking the boxes</label>
                    <div class="flex-container">
                        <div class="ingredient-list">
                            <input type="checkbox" id="tortilla" name="tortilla" value="Tortilla" checked disabled> Tortilla (wheat)<br>
                            <input type="checkbox" id="beef" name="beef" value="Beef"> Beef<br>
                            <input type="checkbox" id="chicken" name="chicken" value="Chicken"> Chicken<br>
                            <input type="checkbox" id="pork" name="pork" value="Pork"> Pork<br>
                            <input type="checkbox" id="cheese" name="cheese" value="Cheese"> Cheese<br>
                            <input type="checkbox" id="sour-cream" name="sour-cream" value="Sour Cream"> Sour cream<br>
                            <input type="checkbox" id="rice" name="rice" value="Rice"> Rice<br>
                            <input type="checkbox" id="beans" name="beans" value="Beans"> Beans<br>
                            <input type="checkbox" id="lettuce" name="lettuce" value="Lettuce"> Lettuce<br>
                            <input type="checkbox" id="onions" name="onions" value="Onions"> Onions<br>
                            <input type="checkbox" id="tomatoes" name="tomatoes" value="Tomato"> Tomatoes<br>
                            <input type="checkbox" id="avocado" name="avocado" value="Avocado"> Avocado<br>
                        </div>
                        <div id="burrito-preview" class="burrito-preview"></div>
                    </div>
                </div>
            </div>

            <!-- Right Column -->
            <div class="form-column right-column">
                <!-- Combined Section Box for Visualization and Slider -->
                <div class="section-box">
                    <label class="section-label">What matters more: cost or environmental impact?</label>
                    <label class="section-sublabel">The Graph below shows all options for your budget and ingredients.<br>
                        To find your perfect cost/impact balance:<br>
                        move the slider to the left to show a preference for lower cost,<br>
                        and to the right for a preference to lower environmental impact<br>
                        The star is indicating your perfect burrito!
                    </label>
                    <div class="preference-visualization-section">
                        <!-- Preference Slider -->
                        <div class="preference-slider">
                            <div class="slider-container">
                                <div class="slider-label left">
                                    Low<br>Cost
                                </div>
                                <input type="range" id="weight-slider" class="styled-slider" min="0" max="100" step="1" value="50">
                                <div class="slider-label right">
                                    Low<br>Environmental<br>Impact
                                </div>
                            </div>
                        </div>
                        <!-- Pareto Front Visualization -->
                        <div class="visualization-container">
                            <svg id="pareto-chart"></svg>
                        </div>
                    </div>
                </div>

                <div class="section-box">
                    <label class="section-label">How's your burrito looking?</label>
                    <div class="confirmation-section">
                        <div class="confirmation-buttons">
                            <button class="confirm-yes" onclick="handleBurritoConfirm(true)">Let's get it! âœ“</button>
                            <button class="confirm-no" onclick="handleBurritoConfirm(false)">Still workin' âœ—</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

            <!-- Full Width Map Section -->
            <div class="map-wrapper">
                <div id="map">
                    <!-- Solution Info Box -->
                    <div class="section-box">
                        <div id="solution-info" class="text-center"></div>
                    </div>

                    <!-- Map Visualization -->
                    <div class="section-box">
                        <label class="section-label">From where are your burrito ingredients?</label>
                        <div class="map-content">
                            <div style="position: relative; width: 100%; display: flex;">
                                <div class="map-container">
                                    <svg id="country-map" width="960" height="500"></svg>
                                </div>
                                <div id="map-legend" class="legend-container"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Popups -->
            <div class="popup-overlay" id="popupOverlay"></div>
            <div class="tooltip" id="tooltip"></div>
            <div class="popup-confirm" id="burritoPopup">
                <div class="popup-content">
                    <div class="popup-emoji">ðŸŒ¯</div>
                    <div class="popup-title">Ready to confirm your burrito?</div>
                    <div class="popup-buttons">
                        <button class="popup-button popup-confirm-btn" onclick="handleBurritoConfirm(true)">Yes, Perfect!</button>
                        <button class="popup-button popup-cancel-btn" onclick="handleBurritoConfirm(false)">Not Yet</button>
                    </div>
                </div>
            </div>
            <div class="no-burrito-popup" id="noBurritoPopup">
                <div class="emoji">ðŸ˜¢</div>
                <div class="message">No burrito found in your budget.<br>Try adjusting your choices!</div>
                <button class="close-button" onclick="closeNoBurritoPopup()">OK, I'll Try Again</button>
            </div>
        </div>

        <!-- JavaScript Code -->
        <script>
            // Splash screen handling
            document.getElementById('startButton').addEventListener('click', function() {
                const splashScreen = document.getElementById('splashScreen');
                const mainContent = document.getElementById('mainContent');

                // Hide splash screen
                splashScreen.classList.add('hidden');

                // Show main content with a slight delay
                setTimeout(() => {
                    mainContent.classList.add('visible');
                    // Trigger any initial setup you need
                    if (typeof updateParetoFront === 'function') {
                        updateParetoFront();
                    }
                }, 500);
            });

            let ingredientData = null;

            // Load ingredient data
            d3.json("final_burrito_data.json").then(function(data) {
                if (!validateIngredientData(data)) {
                    throw new Error("Invalid data structure");
                }
                ingredientData = data;
                console.log("Ingredient data loaded:", ingredientData);

                // Find and modify tortilla checkbox
                const tortillaCheckbox = document.getElementById('tortilla');
                if (tortillaCheckbox) {
                    tortillaCheckbox.checked = true;  // Check by default
                    tortillaCheckbox.disabled = true; // Prevent unchecking
                }

                // Get unique importing countries from the data
                const importingCountries = Object.keys(data);
                console.log("Available importing countries:", importingCountries);

                // Populate the dropdown
                const dropdown = d3.select("#importing-country");

                // Clear existing options
                dropdown.selectAll("option").remove();



                // Add new options and set Australia as the first option
                dropdown.selectAll("option")
                    .data(["Australia", ...importingCountries.filter(country => country !== "Australia").sort()])
                    .enter()
                    .append("option")
                    .attr("value", d => d)
                    .text(d => d);

                // Set Australia as default
                dropdown.property("value", "Australia");

                // Enable all UI elements
                enableUIElements();

            }).catch(function(error) {
                console.error("Error loading Ingredient Data:", error);
                alert("Error loading ingredient data. Please refresh the page.");
            });

            // Function to enable UI elements - redefine this first
            function enableUIElements() {
                // Enable all checkboxes except tortilla
                d3.selectAll("input[type=checkbox]")
                    .filter(function() {
                        return this.id !== 'tortilla';  // Skip the tortilla checkbox
                    })
                    .property("disabled", false)
                    .on("change", function() {
                        updateParetoFront();
                        updateBurritoVisualization();
                    });

                // Enable location dropdown
                const locationDropdown = d3.select("#importing-country");
                locationDropdown
                    .property("disabled", false)
                    .on("change", function() {
                        console.log("Location changed to:", this.value);
                        updateParetoFront();
                    });

                // Enable budget input
                const budgetInput = d3.select("#budget-input");
                const updateButton = d3.select("#update-budget");

                // Function to handle budget update
                function updateBudget() {
                    const budget = +budgetInput.node().value;
                    if (budget <= 0) {
                        alert("Please enter a valid budget greater than 0");
                        budgetInput.node().value = 1;
                        return;
                    }
                    console.log("Budget changed to:", budget);
                    updateParetoFront();
                }

                // Update button click handler
                updateButton.on("click", updateBudget);

                // Enter key handler
                budgetInput.on("keydown", function() {
                    if (d3.event.keyCode === 13) { // 13 is the Enter key code
                        d3.event.preventDefault();
                        updateBudget();
                    }
                });

                // Initial update
                updateParetoFront();
                updateBurritoVisualization();

                console.log("UI elements enabled");
            }

            const ingredientColors = {
                "Tortilla": "#a6cee3",
                "Beef": "#1f78b4",
                "Chicken": "#b2df8a",
                "Pork": "#33a02c",
                "Cheese": "#f7ff00",
                "Sour Cream": "#ff8ab7",
                "Rice": "#fdbf6f",
                "Beans": "#ff7f00",
                "Lettuce": "#cab2d6",
                "Onions": "#8dd3c7",
                "Tomato": "#e31a1c",
                "Avocado": "#b15928"
            };

            const countryNameMapping = {
                        "Argentina": "Argentina",
                        "Australia": "Australia",
                        "Bolivia": "Bolivia",
                        "Brazil": "Brazil",
                        "Cabo Verde": "Cape Verde",
                        "Canada": "Canada",
                        "Chile": "Chile",
                        "Colombia": "Colombia",
                        "Czechia": "Czech Republic",
                        "Guyana": "Guyana",
                        "Iceland": "Iceland",
                        "Luxembourg": "Luxembourg",
                        "Madagascar": "Madagascar",
                        "Mauritius": "Mauritania",
                        "Mexico": "Mexico",
                        "Mozambique": "Mozambique",
                        "Paraguay": "Paraguay",
                        "Philippines": "Philippines",
                        "Romania": "Romania",
                        "Slovakia": "Slovakia",
                        "South Africa": "South Africa",
                        "Tanzania": "United Republic of Tanzania",
                        "Turkey": "Turkey",
                        "Uruguay": "Uruguay",
                        "USA": "USA",
                        "Zambia": "Zambia",
                        "Bahamas": "The Bahamas",
                        "Bolivia (Plurinational State of)": "Bolivia",
                        "Bosnia Herzegovina": "Bosnia and Herzegovina",
                        "CÃ´te d'Ivoire": "Ivory Coast",
                        "Dem. Rep. of the Congo": "Democratic Republic of the Congo",
                        "Dominican Rep.": "Dominican Republic",
                        "Eswatini": "Swaziland",
                        "Guinea-Bissau": "Guinea Bissau",
                        "North Macedonia": "Macedonia",
                        "Russian Federation": "Russia",
                        "Serbia": "Republic of Serbia",
                        "Timor-Leste": "East Timor",
                        "TÃ¼rkiye": "Turkey",
                        "United Kingdom": "England",
                        "United Rep. of Tanzania": "United Republic of Tanzania",
                        "Viet Nam": "Vietnam",
                    };

            // Create reverse mapping
            const reverseCountryMapping = {};
            Object.entries(countryNameMapping).forEach(([key, value]) => {
                reverseCountryMapping[value] = key;
            });

            // Function to convert country name in either direction
            function convertCountryName(countryName, direction = 'forward') {
                if (direction === 'forward') {
                    return countryNameMapping[countryName] || countryName;
                } else {
                    return reverseCountryMapping[countryName] || countryName;
                }
            }

            // Helper function to validate data structure
            function validateIngredientData(data) {
                if (!data || typeof data !== 'object') {
                    console.error('Invalid ingredient data structure');
                    return false;
                }

                // Check first level (importing countries)
                for (const country in data) {
                    if (!data[country] || typeof data[country] !== 'object') {
                        console.error(`Invalid data structure for country: ${country}`);
                        return false;
                    }

                    // Check second level (ingredients)
                    for (const ingredient in data[country]) {
                        if (!data[country][ingredient] || typeof data[country][ingredient] !== 'object') {
                            console.error(`Invalid data structure for ingredient: ${ingredient} in ${country}`);
                            return false;
                        }

                        // Check third level (source countries)
                        for (const sourceCountry in data[country][ingredient]) {
                            const sourceData = data[country][ingredient][sourceCountry];
                            if (!sourceData ||
                                typeof sourceData.cost !== 'number' ||
                                typeof sourceData.impact !== 'number') {
                                console.error(`Invalid data for ${ingredient} from ${sourceCountry} in ${country}`);
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            // Modified initialization function with proper data validation
            function initializePopulation(selectedIngredients, importingCountry, budget, populationSize = 50) {
                const population = [];
                let attempts = 0;
                const maxAttempts = populationSize * 10;

                // console.log(`Initializing population for ${selectedIngredients.length} ingredients with budget ${budget}`);

                // Validate ingredient data exists for importing country
                if (!ingredientData[importingCountry]) {
                    console.error(`No data found for importing country: ${importingCountry}`);
                    return population;
                }

                while (population.length < populationSize && attempts < maxAttempts) {
                    const individual = { solution: {} };
                    let validIndividual = true;
                    let currentCost = 0;

                    for (const ingredient of selectedIngredients) {
                        // Check if ingredient data exists
                        const ingredientOptions = ingredientData[importingCountry][ingredient];
                        if (!ingredientOptions) {
                            console.warn(`No data found for ${ingredient} in ${importingCountry}`);
                            validIndividual = false;
                            break;
                        }

                        // Get available source countries with valid cost data
                        const sourceOptions = Object.entries(ingredientOptions)
                            .filter(([_, data]) => (
                                data &&
                                typeof data.cost === 'number' &&
                                !isNaN(data.cost) &&
                                data.cost + currentCost <= budget
                            ))
                            .map(([country, data]) => ({
                                country,
                                cost: data.cost
                            }));

                        if (sourceOptions.length === 0) {
                            console.warn(`No affordable sources found for ${ingredient}`);
                            validIndividual = false;
                            break;
                        }

                        // Select random source country from affordable options
                        const selectedOption = sourceOptions[Math.floor(Math.random() * sourceOptions.length)];
                        individual.solution[ingredient] = selectedOption.country;
                        currentCost += selectedOption.cost;
                    }

                    if (validIndividual) {
                        calculateCostAndImpact(individual, importingCountry);
                        if (individual.cost !== undefined && individual.cost <= budget) {
                            population.push(individual);
                            // console.log(`Added valid individual with cost: ${individual.cost}`);
                        }
                    }

                    attempts++;
                }

                console.log(`Generated ${population.length} valid individuals after ${attempts} attempts`);
                return population;
            }

            // Calculate cost and impact
            function calculateCostAndImpact(individual, importingCountry) {
                let totalCost = 0;
                let totalImpact = 0;
                let validIndividual = true;

                for (const [ingredient, country] of Object.entries(individual.solution)) {
                    const data = ingredientData[importingCountry]?.[ingredient]?.[country];
                    if (data) {
                        totalCost += data.cost;
                        totalImpact += data.impact;
                    } else {
                        console.warn(`Invalid data for ${ingredient} from ${country}`);
                        validIndividual = false;
                        break;
                    }
                }

                if (validIndividual) {
                    individual.cost = totalCost;
                    individual.impact = totalImpact;
                } else {
                    individual.cost = undefined;
                    individual.impact = undefined;
                }
            }

            // Non-dominated sorting
            function nonDominatedSorting(population) {
                let fronts = [[]];
                population.forEach(p => {
                    p.dominatedCount = 0;
                    p.dominatedSet = [];
                    population.forEach(q => {
                        if ((q.cost <= p.cost && q.impact <= p.impact) && (q.cost < p.cost || q.impact < p.impact)) {
                            p.dominatedCount += 1;
                        } else if ((p.cost <= q.cost && p.impact <= q.impact) && (p.cost < q.cost || p.impact < q.impact)) {
                            p.dominatedSet.push(q);
                        }
                    });
                    if (p.dominatedCount === 0) {
                        p.rank = 0;
                        fronts[0].push(p);
                    }
                });
                let i = 0;
                while (fronts[i].length > 0) {
                    const nextFront = [];
                    fronts[i].forEach(p => {
                        p.dominatedSet.forEach(q => {
                            q.dominatedCount -= 1;
                            if (q.dominatedCount === 0) {
                                q.rank = i + 1;
                                nextFront.push(q);
                            }
                        });
                    });
                    i++;
                    fronts.push(nextFront);
                }
                return fronts.slice(0, -1);
            }

            // Calculate crowding distance
            function calculateCrowdingDistance(front) {
                const l = front.length;
                if (l === 0) return;

                front.forEach(ind => ind.crowdingDistance = 0);
                ['cost', 'impact'].forEach(key => {
                    front.sort((a, b) => a[key] - b[key]);
                    front[0].crowdingDistance = front[l - 1].crowdingDistance = Infinity;
                    const min = front[0][key];
                    const max = front[l - 1][key];
                    for (let i = 1; i < l - 1; i++) {
                        front[i].crowdingDistance += (front[i + 1][key] - front[i - 1][key]) / (max - min || 1); // Avoid division by zero
                    }
                });
            }

            // Selection using tournament selection
            function selection(population, numToSelect) {
                const selected = [];
                while (selected.length < numToSelect) {
                    const tournament = [];
                    const tournamentSize = 2;
                    for (let i = 0; i < tournamentSize; i++) {
                        const randomIndividual = population[Math.floor(Math.random() * population.length)];
                        tournament.push(randomIndividual);
                    }
                    tournament.sort((a, b) => {
                        if (a.rank !== b.rank) {
                            return a.rank - b.rank;
                        } else {
                            return b.crowdingDistance - a.crowdingDistance;
                        }
                    });
                    selected.push(tournament[0]);
                }
                return selected;
            }

            // Crossover operator
            function crossover(parent1, parent2) {
                const child = { solution: {} };
                for (const ingredient in parent1.solution) {
                    child.solution[ingredient] = Math.random() < 0.5 ? parent1.solution[ingredient] : parent2.solution[ingredient];
                }
                return child;
            }

            // Mutation operator
            function mutation(individual, importingCountry, mutationRate = 0.1) {
                for (const ingredient in individual.solution) {
                    if (Math.random() < mutationRate) {
                        const countries = Object.keys(ingredientData[importingCountry][ingredient]);
                        individual.solution[ingredient] = countries[Math.floor(Math.random() * countries.length)];
                    }
                }
                return individual;
            }

            // Run NSGA-II optimization
            function runNSGA2Optimization(selectedIngredients, importingCountry, budget) {
                console.log(`Starting optimization with budget: ${budget}`);

                // Validate inputs
                if (!ingredientData[importingCountry]) {
                    throw new Error(`Invalid home country: ${importingCountry}`);
                }

                // Calculate minimum possible cost before attempting optimization
                let minPossibleCost = 0;
                let debugCosts = {};

                for (const ingredient of selectedIngredients) {
                    if (ingredientData[importingCountry][ingredient]) {
                        const costs = Object.values(ingredientData[importingCountry][ingredient])
                            .map(data => data.cost)
                            .filter(cost => typeof cost === 'number' && !isNaN(cost));

                        if (costs.length > 0) {
                            const minCost = Math.min(...costs);
                            minPossibleCost += minCost;
                            debugCosts[ingredient] = {
                                allCosts: costs,
                                minCost: minCost
                            };
                        } else {
                            console.error(`No valid costs found for ${ingredient} in ${importingCountry}`);
                        }
                    } else {
                        console.error(`No data found for ${ingredient} in ${importingCountry}`);
                    }
                }

                console.log('Debug costs for each ingredient:', debugCosts);
                console.log(`Total minimum possible cost: ${minPossibleCost}`);

                // Initial population
                let population = initializePopulation(selectedIngredients, importingCountry, budget);

                if (population.length === 0) {
                    console.warn("Could not generate initial population within budget");
                    return [];
                }

                const generations = 50;
                const populationSize = population.length;

                // Main NSGA-II loop
                for (let generation = 0; generation < generations; generation++) {
                    // console.log(`Generation ${generation + 1}`);

                    // Selection
                    const matingPool = selection(population, populationSize);

                    // Create new population
                    let offspring = [];
                    while (offspring.length < populationSize) {
                        const parent1 = matingPool[Math.floor(Math.random() * matingPool.length)];
                        const parent2 = matingPool[Math.floor(Math.random() * matingPool.length)];

                        let child = crossover(parent1, parent2);
                        child = mutation(child, importingCountry);

                        calculateCostAndImpact(child, importingCountry);

                        if (child.cost !== undefined && child.cost <= budget) {
                            offspring.push(child);
                        }
                    }

                    // Combine populations
                    population = [...population, ...offspring];

                    // Non-dominated sorting
                    const fronts = nonDominatedSorting(population);

                    // Select next generation
                    population = [];
                    for (const front of fronts) {
                        if (population.length + front.length <= populationSize) {
                            population.push(...front);
                        } else {
                            calculateCrowdingDistance(front);
                            front.sort((a, b) => b.crowdingDistance - a.crowdingDistance);
                            population.push(...front.slice(0, populationSize - population.length));
                            break;
                        }
                    }

                    // console.log(`Population size after generation ${generation + 1}: ${population.length}`);
                }

                // Get final Pareto front
                const finalFronts = nonDominatedSorting(population);
                const paretoFront = finalFronts[0] || [];

                console.log(`Final Pareto front size: ${paretoFront.length}`);
                return paretoFront;
            }

            let currentParetoFront=[]

            // Select the optimal solution based on slider position
            function selectOptimalSolution(paretoFront, costWeight) {
                // If called with one parameter, assume it's costWeight and use currentParetoFront
                if (arguments.length === 1) {
                    costWeight = paretoFront;
                    paretoFront = currentParetoFront;
                }

                if (!paretoFront || paretoFront.length === 0) {
                    return null;
                }

                // Sort solutions by impact (ascending) because left = low cost (high impact)
                // and right = high cost (low impact)
                const sortedSolutions = [...paretoFront].sort((a, b) => b.impact - a.impact);

                // Use the costWeight directly as a percentage along the curve
                // Scale the costWeight (0-1) to an index in our sorted array
                const index = Math.min(
                    Math.floor(costWeight * (sortedSolutions.length - 1)),
                    sortedSolutions.length - 1
                );

                return sortedSolutions[index];
            }

            function updateTooltipPosition(event, tooltip) {
                // Get viewport dimensions
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                // Get tooltip dimensions
                const tooltipNode = tooltip.node();
                const tooltipRect = tooltipNode.getBoundingClientRect();

                // Get cursor position relative to the viewport
                const cursorX = event.clientX;
                const cursorY = event.clientY;

                // Default position (to the right and below cursor)
                let left = cursorX + 15;
                let top = cursorY + 15;

                // Check right edge of viewport
                if (left + tooltipRect.width > viewportWidth - 20) {
                    // Position to the left of cursor instead
                    left = cursorX - tooltipRect.width - 15;
                }

                // Check bottom edge of viewport
                if (top + tooltipRect.height > viewportHeight - 20) {
                    // Position above cursor instead
                    top = cursorY - tooltipRect.height - 15;
                }

                // Ensure minimum distance from edges
                left = Math.max(20, Math.min(left, viewportWidth - tooltipRect.width - 20));
                top = Math.max(20, Math.min(top, viewportHeight - tooltipRect.height - 20));

                // Consider scroll position for fixed positioning
                left += window.pageXOffset;
                top += window.pageYOffset;

                return { left, top };
            }

            // Display Pareto Front with hover tooltips and highlight the optimal solution
            function displayParetoFront(paretoFront, finalSolution) {
                const svg = d3.select("#pareto-chart");
                const container = d3.select(".visualization-container").node();
                const svgWidth = container.getBoundingClientRect().width;
                const svgHeight = 300;

                // Set SVG size
                svg.attr("width", svgWidth)
                   .attr("height", svgHeight);

                // Update margins to match slider container
                const margin = {
                    top: 10,
                    right: 90, // Increased to match slider label width
                    bottom: 30,
                    left: 90  // Increased to match slider label width
                };

                const width = svgWidth - margin.left - margin.right;
                const height = svgHeight - margin.top - margin.bottom;

                svg.selectAll("*").remove();

                if (paretoFront.length === 0) return;

                // Filter out individuals with undefined cost or impact
                paretoFront = paretoFront.filter(d => d.cost !== undefined && d.impact !== undefined);

                const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

                // Calculate minimum and maximum values for both axes
                const minCost = d3.min(paretoFront, d => d.cost);
                const maxCost = d3.max(paretoFront, d => d.cost);
                const minImpact = d3.min(paretoFront, d => d.impact);
                const maxImpact = d3.max(paretoFront, d => d.impact);

                // Add padding to the ranges (5% padding)
                const costPadding = (maxCost - minCost) * 0.1;
                const impactPadding = (maxImpact - minImpact) * 0.1;

                // Create scales with dynamic ranges
                const x = d3.scaleLinear()
                    .range([0, width])
                    .domain([minCost - costPadding, maxCost + costPadding]);

                const y = d3.scaleLinear()
                    .range([height, 0])
                    .domain([minImpact - impactPadding, maxImpact + impactPadding])

                // Axes
                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x).ticks(5))
                    .append("text")
                    .attr("class", "axis-label")
                    .attr("x", width / 2)
                    .attr("y", 35)
                    .style("text-anchor", "middle")
                    .style("font-size", "16px")
                    .text("Cost");

                g.append("g")
                    .attr("class", "axis")
                    .call(d3.axisLeft(y).ticks(5).tickFormat(d=>d.toFixed(2)))
                    .append("text")
                    .attr("class", "axis-label")
                    .attr("x", -height / 2)
                    .attr("y", -50)
                    .attr("transform", "rotate(-90)")
                    .style("text-anchor", "middle")
                    .style("font-size", "16px")
                    .text("Impact");

                // Select the tooltip div
                const tooltip = d3.select(".tooltip");

                // Dots with tooltip events
                g.selectAll("circle.pareto-point")
                    .data(paretoFront)
                    .enter().append("circle")
                    .attr("class", "pareto-point")
                    .attr("cx", d => x(d.cost))
                    .attr("cy", d => y(d.impact))
                    .attr("r", 5)
                    .attr("fill", "grey")
                    .on("mouseover", function(d) {
                        const pos = {
                            left: d3.event.pageX - 250,
                            top: d3.event.pageY - 40
                        };

                        tooltip
                            .style("left", pos.left + "px")
                            .style("top", pos.top + "px")
                            .html(`Cost: $${d.cost.toFixed(2)}<br>Impact: ${d.impact.toFixed(2)}`)
                            .style("opacity", 1);
                    })
                    .on("mouseout", function() {
                        tooltip.style("opacity", 0);
                    });

                // Highlight the optimal solutions
                if (finalSolution) {
                    const optimalX = x(finalSolution.cost);
                    const optimalY = y(finalSolution.impact);

                    // Append the optimal point
                    g.append("path")
                        .attr("class", "optimal-point")
                        .attr("d", "M 0 -7 L 2 -2 L 7 -2 L 3 1 L 4 6 L 0 3 L -4 6 L -3 1 L -7 -2 L -2 -2 Z")  // Star path
                        .attr("transform", `translate(${optimalX}, ${optimalY}) scale(2)`) // Position the star
                        .on("mouseover", function() {
                            const pos = {
                                left: d3.event.pageX - 250,
                                top: d3.event.pageY - 40
                            };

                            tooltip
                                .style("left", pos.left + "px")
                                .style("top", pos.top + "px")
                                .html(`Optimal Solution<br>Cost: $${finalSolution.cost.toFixed(2)}<br>Impact: ${finalSolution.impact.toFixed(2)}`)
                                .style("opacity", 1);
                        })
                        .on("mouseout", function() {
                            tooltip.style("opacity", 0);
                        });

                    // Append label with cost and impact
                    g.append("text")
                        .attr("class", "optimal-label")
                        .attr("x", optimalX)
                        .attr("y", optimalY + 15)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "12px")
                        .attr("fill", "black")
                        .append("tspan")
                            .attr("x", optimalX + 50)
                            .attr("y", optimalY -5)
                            .text(`Cost: $${finalSolution.cost.toFixed(2)}`)
                        .append("tspan")
                            .attr("x", optimalX + 50)
                            .attr("y", optimalY + 10)
                            .text(`Impact: ${finalSolution.impact.toFixed(2)}`);
                }
            }

            // Display Solution Info
            function displaySolutionInfo(finalSolution) {
                const totalCost = finalSolution.cost.toFixed(2);
                const totalImpact = finalSolution.impact.toFixed(2);
                const countries = Object.values(finalSolution.solution);
                const uniqueCountries = [...new Set(countries)];
                const numberOfCountries = uniqueCountries.length;

                const solutionInfoDiv = d3.select("#solution-info");
                solutionInfoDiv.html(
                    `<p>Total Cost: $${totalCost} | Total Environmental Impact: ${totalImpact} | Number of Countries: ${numberOfCountries}</p>`
                );
            }

            // Modified displayMap function with right-aligned tooltips
            function displayMap(finalSolution, importingCountry) {
                const svg = d3.select("#country-map");
                svg.selectAll("*").remove();

                if (!finalSolution) {
                    console.log("No valid solution, clearing map.");
                    return;
                }

                const width = +svg.attr("width");
                const height = +svg.attr("height");
                const projection = d3.geoRobinson()
                    .scale(170)
                    .center([30, 15])
                    .translate([width / 2, height / 2]);

                const path = d3.geoPath().projection(projection);

                // Ensure the map-legend div exists
                let legendContainer = d3.select("#map-legend");
                if (legendContainer.empty()) {
                    legendContainer = d3.select(".map-content")
                        .append("div")
                        .attr("id", "map-legend")
                        .attr("class", "legend-container");
                }

                // Function to create stripe pattern
                function createStripePattern(svg, countryName, colors) {
                    const patternId = `stripes-${countryName.replace(/\s+/g, '-')}`;

                    const pattern = svg.append("defs")
                        .append("pattern")
                        .attr("id", patternId)
                        .attr("patternUnits", "userSpaceOnUse")
                        .attr("width", 10)
                        .attr("height", 10)
                        .attr("patternTransform", "rotate(45)");

                    // Add stripes for each color
                    colors.forEach((color, index) => {
                        const stripeWidth = 10 / colors.length;
                        pattern.append("rect")
                            .attr("x", index * stripeWidth)
                            .attr("width", stripeWidth)
                            .attr("height", 10)
                            .attr("fill", color);
                    });

                    return `url(#${patternId})`;
                }

                d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson").then(function(data) {
                    // Create map of countries to their ingredients
                    const countryIngredients = {};
                    Object.entries(finalSolution.solution).forEach(([ingredient, country]) => {
                        if (!countryIngredients[country]) {
                            countryIngredients[country] = [];
                        }
                        countryIngredients[country].push(ingredient);
                    });

                    // Base map
                    svg.append("g")
                        .selectAll("path")
                        .data(data.features)
                        .enter().append("path")
                        .attr("d", path)
                        .attr("fill", "lightgray")
                        .attr("stroke", "white");

                    // Highlight importing country
                    const importingCountryName = convertCountryName(importingCountry, 'forward');
                    if (importingCountryName) {
                        svg.selectAll("path")
                            .filter(d => d.properties && d.properties.name === importingCountryName)
                            .style("stroke", "black")
                            .style("stroke-width", 3);
                    }

                    // Color source countries
                    Object.entries(countryIngredients).forEach(([country, ingredients]) => {
                        const countryName = convertCountryName(country, 'forward');
                        const colors = ingredients.map(ingredient => ingredientColors[ingredient]);

                        const fill = ingredients.length > 1
                            ? createStripePattern(svg, countryName, colors)
                            : colors[0];

                        svg.selectAll("path")
                            .filter(d => d.properties && d.properties.name === countryName)
                            .style("fill", fill)
                            .attr("data-ingredients", ingredients.join(", "));
                    });

                    // Update tooltip to show all ingredients
                    svg.selectAll("path")
                        .on("mouseover", function(d) {
                            const ingredients = d3.select(this).attr("data-ingredients");
                            if (ingredients) {
                                const pos = updateTooltipPosition(d3.event, d3.select(".tooltip"));
                                d3.select(".tooltip")
                                    .style("left", pos.left + "px")
                                    .style("top", pos.top + "px")
                                    .html(`
                                        <strong>${d.properties.name}</strong><br>
                                        Ingredients: ${ingredients}
                                    `)
                                    .style("opacity", 1);
                            }
                        })
                        .on("mouseout", function() {
                            d3.select(".tooltip").style("opacity", 0);
                        });

                    // Create legend
                    createActiveLegend(finalSolution, importingCountry);
                });
            }

            function preventLabelOverlap(svg, labelClass) {
                const labels = svg.selectAll(labelClass).nodes();
                const padding = 15; // Minimum distance between labels

                for (let i = 0; i < labels.length; i++) {
                    for (let j = i + 1; j < labels.length; j++) {
                        const labelA = labels[i].getBBox();
                        const labelB = labels[j].getBBox();

                        if (isOverlapping(labelA, labelB, padding)) {
                            // Shift labelB down by padding
                            const currentY = parseFloat(d3.select(labels[j]).attr("y")) + padding;
                            d3.select(labels[j]).attr("y", currentY);
                        }
                    }
                }
            }

            function createActiveLegend(finalSolution, importingCountry) {
                // Clear existing legend
                d3.select("#map-legend").selectAll("*").remove();

                const svg = d3.select("#country-map");
                const width = +svg.attr("width");
                const height = +svg.attr("height");
                const projection = d3.geoRobinson()
                    .scale(170)
                    .center([0, 15])
                    .translate([width / 2, height / 2]);

                const tooltip = d3.select(".tooltip");

                // Create legend container
                const legendContainer = d3.select("#map-legend");

                // Add legend titles
                legendContainer.append("div")
                    .attr("class", "legend-title")
                    .text("Click to show/hide labels");

                // Add home country section
                legendContainer.append("div")
                    .attr("class", "legend-title")
                    .text("Home Country");

                // Create import country legend item
                const importingItem = legendContainer.append("div")
                    .attr("class", "legend-item")
                    .style("cursor", "pointer")
                    .style("opacity", 0.6)
                    .on("click", function() {
                        const isVisible = !d3.select(this).classed("active");
                        d3.select(this).classed("active", isVisible);
                        d3.select(this).style("opacity", isVisible ? 1 : 0.6);
                        handleHomeCountryLabel(svg, importingCountry, projection, isVisible);
                    });

                // Add color box and text for importing country
                importingItem.append("div")
                    .attr("class", "color-box")
                    .style("background-color", "lightgray")
                    .style("border", "3px solid black");

                importingItem.append("span")
                    .text(importingCountry);

                // Add separator
                legendContainer.append("hr")
                    .style("margin", "10px 0")
                    .style("border", "1px solid #ccc");

                // Add ingredients section
                legendContainer.append("div")
                    .attr("class", "legend-title")
                    .text("Ingredients");

                // Get active ingredients
                const activeIngredients = Object.keys(finalSolution.solution);
                // Create legend items for ingredients
                const legendItems = legendContainer.selectAll(".ingredient-legend-item")
                    .data(activeIngredients)
                    .enter()
                    .append("div")
                    .attr("class", "legend-item")
                    .style("cursor", "pointer")
                    .each(function(ingredient) {
                        d3.select(this).datum({
                            ingredient: ingredient,
                            isVisible: false
                        });
                    })
                    .on("click", function(d) {
                        const isVisible = !d.isVisible;
                        d.isVisible = isVisible;

                        d3.select(this).style("opacity", isVisible ? 1 : 0.6);

                        const sourceCountry = finalSolution.solution[d.ingredient];
                        const data = ingredientData[importingCountry][d.ingredient][sourceCountry];
                        const coords = projection([data.Longitude, data.Latitude]);

                        if (coords) {
                            // Fixed offset to the right
                            console.log("sourcecountry:", sourceCountry)
                            const offsetX = (sourceCountry === "New Zealand") ? -150
                                           : (sourceCountry === "Australia") ? -100
                                           : 0;
                            let labelX = coords[0] + offsetX;
                            let labelY = coords[1];  // Start at same vertical position as country


                            // Remove existing label and line
                            svg.selectAll(`.label-group[data-ingredient="${d.ingredient}"]`).remove();
                            svg.selectAll(`line[data-ingredient="${d.ingredient}"]`).remove();

                            if (isVisible) {
                                // Create label group with tooltip
                                const labelGroup = svg.append("g")
                                    .attr("class", "label-group")
                                    .attr("data-ingredient", d.ingredient)
                                    .attr("transform", `translate(${labelX},${labelY})`);

                                // Add background rectangle
                                labelGroup.append("rect")
                                    .attr("x", -6)
                                    .attr("y", -6)
                                    .attr("width", 144)
                                    .attr("height", 63)
                                    .attr("fill", ingredientColors[d.ingredient])
                                    .attr("stroke", "#666")
                                    .attr("stroke-width", 1)
                                    .attr("rx", 4)
                                    .style("opacity", .8);

                                // Add text content
                                const label = labelGroup.append("text")
                                    .attr("class", "label")
                                    .style("fill", "black")
                                    .style("font-size", "12px");

                                label.append("tspan")
                                    .attr("x", 0)
                                    .attr("y", 6)
                                    .text(sourceCountry)
                                    .style("font-weight", "bold");

                                label.append("tspan")
                                    .attr("x", 0)
                                    .attr("y", 21)
                                    .text(`Ingredient: ${d.ingredient}`);

                                label.append("tspan")
                                    .attr("x", 0)
                                    .attr("y", 36)
                                    .text(`Cost: $${data.cost.toFixed(2)}`);

                                label.append("tspan")
                                    .attr("x", 0)
                                    .attr("y", 51)
                                    .text(`Impact: ${data.impact.toFixed(2)}`);

                                // Add connecting line
                                svg.append("line")
                                    .attr("class", "line")
                                    .attr("data-ingredient", d.ingredient)
                                    .attr("x1", coords[0]-90)
                                    .attr("y1", coords[1])
                                    .attr("x2", labelX)
                                    .attr("y2", labelY)
                                    .attr("stroke", ingredientColors[d.ingredient])
                                    .attr("stroke-width", 2)
                                    .on("mouseover", function() {
                                        const pos = updateTooltipPosition(d3.event, tooltip);
                                        tooltip
                                            .style("left", pos.left + "px")
                                            .style("top", pos.top + "px")
                                            .html(`
                                                <strong>${sourceCountry}</strong><br>
                                                Ingredient: ${d.ingredient}<br>
                                                Cost: $${data.cost.toFixed(2)}<br>
                                                Impact: ${data.impact.toFixed(2)}
                                            `)
                                            .style("opacity", 1);
                                    })
                                    .on("mouseout", function() {
                                        tooltip.style("opacity", 0);
                                    });
                            }
                        }
                    });

                // Add color boxes to legend items
                legendItems.append("div")
                    .attr("class", "color-box")
                    .style("background-color", d => ingredientColors[d.ingredient]);

                // Add ingredient names to legend items
                legendItems.append("span")
                    .text(d => d.ingredient);

                // Set initial opacity
                legendItems.style("opacity", 0.6);
            }

            function handleHomeCountryLabel(svg, importingCountry, projection, isVisible) {
                const tooltip = d3.select(".tooltip");

                // Remove existing home country labels
                svg.selectAll(".home-country-label").remove();
                svg.selectAll(".home-country-line").remove();

                if (isVisible) {
                    d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson").then(function(geoData) {
                        const countryName = convertCountryName(importingCountry, 'forward');
                        const countryFeature = geoData.features.find(f => f.properties.name === countryName);

                        if (countryFeature) {
                            const path = d3.geoPath().projection(projection);
                            const centroid = path.centroid(countryFeature);

                            const labelX = centroid[0];
                            const labelY = centroid[1];

                            // Create label group with tooltip
                            const labelGroup = svg.append("g")
                                .attr("class", "home-country-label")
                                .on("mouseover", function() {
                                    const pos = updateTooltipPosition(d3.event, tooltip);
                                    tooltip
                                        .style("left", pos.left + "px")
                                        .style("top", pos.top + "px")
                                        .html(`
                                            <strong>${importingCountry}</strong><br>
                                            Home Country
                                        `)
                                        .style("opacity", 1);
                                })
                                .on("mouseout", function() {
                                    tooltip.style("opacity", 0);
                                });

                            // Add background
                            labelGroup.append("rect")
                                .attr("x", labelX - 60)
                                .attr("y", labelY - 20)
                                .attr("width", 120)
                                .attr("height", 50)
                                .attr("fill", "white")
                                .attr("stroke", "#666")
                                .attr("stroke-width", 1)
                                .attr("rx", 4)
                                .style("opacity", .9);

                            // Add text
                            const label = labelGroup.append("text")
                                .style("fill", "black")
                                .style("font-size", "12px")
                                .style("text-anchor", "left");

                            label.append("tspan")
                                .attr("x", labelX-50)
                                .attr("y", labelY)
                                .text(importingCountry)
                                .style("font-weight", "bold");

                            label.append("tspan")
                                .attr("x", labelX-50)
                                .attr("y", labelY + 15)
                                .text("Home Country");


                            // Add connecting line with tooltip
                            svg.append("line")
                                .attr("class", "home-country-line")
                                .attr("x1", centroid[0]-90)
                                .attr("y1", centroid[1])
                                .attr("x2", labelX-60)
                                .attr("y2", labelY)
                                .attr("stroke", "black")
                                .attr("stroke-width", 2)
                                .on("mouseover", function() {
                                    const pos = updateTooltipPosition(d3.event, tooltip);
                                    tooltip
                                        .style("left", pos.left + "px")
                                        .style("top", pos.top + "px")
                                        .html(`
                                            <strong>${importingCountry}</strong><br>
                                            Home Country
                                        `)
                                        .style("opacity", 1);
                                })
                                .on("mouseout", function() {
                                    tooltip.style("opacity", 0);
                                });
                        }
                    });
                }
            }

            function updateBurritoVisualization() {
                const burritoPreview = document.getElementById('burrito-preview');
                burritoPreview.innerHTML = ''; // Clear existing images

                // Order of ingredients from bottom to top
                const ingredientOrder = [
                    'tortilla',
                    'lettuce',
                    'rice',
                    'beans',
                    'beef',
                    'chicken',
                    'pork',
                    'cheese',
                    'onions',
                    'tomatoes',
                    'sour-cream',
                    'avocado'
                ];

                // Add images for checked ingredients in order
                ingredientOrder.forEach((ingredient, index) => {
                    const checkbox = document.getElementById(ingredient);
                    if (checkbox && checkbox.checked) {
                        const img = document.createElement('img');
                        img.src = `images2/${ingredient}.png`;
                        img.alt = ingredient;
                        img.style.zIndex = index;
                        burritoPreview.appendChild(img);
                    }
                });

                // Show placeholder text if no ingredients selected
                if (burritoPreview.children.length === 0) {
                    const placeholder = document.createElement('div');
                    placeholder.style.position = 'absolute';
                    placeholder.style.top = '50%';
                    placeholder.style.left = '50%';
                    placeholder.style.transform = 'translate(-50%, -50%)';
                    placeholder.style.color = '#666';
                    placeholder.textContent = 'Select ingredients to build your burrito';
                    burritoPreview.appendChild(placeholder);
                }
            }

            function updateParetoFront() {
                if (!ingredientData) {
                    console.warn("Ingredient data not yet loaded");
                    return;
                }

                const selectedCheckboxes = Array.from(document.querySelectorAll("input[type=checkbox]:checked"))
                    .map(el => el.value);
                const selectedIngredients = [...selectedCheckboxes];
                if (!selectedIngredients.includes("Tortilla")) {
                    selectedIngredients.push("Tortilla");
                }

                const budget = +d3.select("#budget-input").node().value;
                if (isNaN(budget) || budget <= 0) {
                    alert("Please enter a valid budget.");
                    return;
                }

                const importingCountry = d3.select("#importing-country").node().value;
                const costWeight = +d3.select("#weight-slider").property("value") / 100;

                // Calculate and store Pareto front
                currentParetoFront = runNSGA2Optimization(selectedIngredients, importingCountry, budget);

                // Clear existing visualizations
                d3.select("#pareto-chart").selectAll("*").remove();
                d3.select("#country-map").selectAll("*").remove();
                d3.select("#solution-info").html("");
                d3.select("#map-legend").selectAll("*").remove();

                if (!currentParetoFront || currentParetoFront.length === 0) {
                    showNoBurritoPopup();
                    return;
                }

                const finalSolution = selectOptimalSolution(currentParetoFront, costWeight);

                if (finalSolution) {
                    displayParetoFront(currentParetoFront, finalSolution);
                    displaySolutionInfo(finalSolution);
                    displayMap(finalSolution, importingCountry);
                }
            }

            // Updated slider event listener
            d3.select("#weight-slider")
                .on("input", function() {
                    const costWeight = +this.value / 100;
                    const importingCountry = d3.select("#importing-country").node().value;

                    if (!currentParetoFront || currentParetoFront.length === 0) {
                        return;
                    }

                    // Use existing Pareto front to select new solution
                    const finalSolution = selectOptimalSolution(currentParetoFront, costWeight);

                    if (finalSolution) {
                        // Update visualizations with new selection
                        displayParetoFront(currentParetoFront, finalSolution);
                        displaySolutionInfo(finalSolution);
                        displayMap(finalSolution, importingCountry);
                    }
                });

            // Add new functions for popup handling
            function showNoBurritoPopup() {
                const popup = document.getElementById('noBurritoPopup');
                const overlay = document.getElementById('popupOverlay');
                popup.classList.add('show');
                overlay.classList.add('show');
            }

            function closeNoBurritoPopup() {
                const popup = document.getElementById('noBurritoPopup');
                const overlay = document.getElementById('popupOverlay');
                popup.classList.remove('show');
                overlay.classList.remove('show');
            }

            // Close popup when clicking overlay
            document.getElementById('popupOverlay').addEventListener('click', closeNoBurritoPopup);

            // Get popup elements
            const burritoPopup = document.getElementById('burritoPopup');
            const confirmButton = document.getElementById('confirmBurrito');

            // Show popup when confirm button is clicked
            confirmButton.addEventListener('click', (event) => {
                const buttonRect = confirmButton.getBoundingClientRect();
                const popupWidth = 300; // Width of the popup

                // Position popup near the button
                burritoPopup.style.left = `${buttonRect.left + (buttonRect.width - popupWidth) / 2}px`;
                burritoPopup.style.top = `${buttonRect.bottom + 10}px`; // 10px below the button

                burritoPopup.classList.add('show');
            });

            // Modified handleBurritoConfirm function
            function handleBurritoConfirm(isConfirmed) {
                // Show overlay
                const overlay = document.getElementById('popupOverlay');
                overlay.classList.add('show');

                if (isConfirmed) {
                    const successPopup = document.createElement('div');
                    successPopup.className = 'success-popup';
                    successPopup.innerHTML = `
                        <div style="font-size: 48px; margin-bottom: 15px;">ðŸŽ‰</div>
                        <div style="font-size: 24px; color: #2d3748; margin-bottom: 15px;">Fantastic Choice!</div>
                        <div style="color: #4a5568;">Your perfect burrito combination has been confirmed.</div>
                    `;
                    document.body.appendChild(successPopup);

                    setTimeout(() => {
                        successPopup.style.opacity = '0';
                        overlay.classList.remove('show');
                        setTimeout(() => successPopup.remove(), 300);
                    }, 2000);
                } else {
                    const adjustPopup = document.createElement('div');
                    adjustPopup.className = 'adjust-popup';
                    adjustPopup.innerHTML = `
                        <div style="font-size: 48px; margin-bottom: 15px;">ðŸ”„</div>
                        <div style="font-size: 24px; color: #2d3748; margin-bottom: 15px;">No problem!</div>
                        <div style="color: #4a5568;">Keep working on your perfect burrito combination.</div>
                    `;
                    document.body.appendChild(adjustPopup);

                    setTimeout(() => {
                        adjustPopup.style.opacity = '0';
                        overlay.classList.remove('show');
                        setTimeout(() => adjustPopup.remove(), 300);
                    }, 2000);
                }
            }
            // Close popup when clicking outside
            document.addEventListener('click', (event) => {
                if (!burritoPopup.contains(event.target) && event.target !== confirmButton) {
                    burritoPopup.classList.remove('show');
                }
            });

        </script>
    </body>
    </html>