<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <title>Games Rating: 2015 - 2019</title>

    <script src = "../lib/d3.v5.min.js"></script>
    <script src="../lib/d3-tip.min.js"></script>
    <script src="../lib/d3-dsv.min.js"></script>
    <script src="../lib/d3-geo-projection.v2.min.js"></script>
    <script src="../lib/topojson.v2.min.js"></script>
    <script src="../lib/d3-legend.min.js"></script>


    <style>
        body {
            font-family: sans-serif;
        }
        #tooltip {

            text-align: left;
            padding: 8px;
            background: lightsteelblue;
            border: 2px;
            border-radius: 8px;
            pointer-events: none;
        }
    
    </style>


</head>
<body>

    <h1>Games Rating by Country 2015-2019</h1>

    <!-- Create dropdown element here. Options should be added after reading in game file, they should not be created here.-->
    <select id ="gameDropdown">

    </select>
    <svg id ="choropleth" width = "960" height = "500">
        <g id = "countries">
            <path></path>
            </g>
        <g id= "legend"></g>
    </svg>
    <div id= "tooltip" display = "block" pointer-events = "none"></div>



    <script>
    
        // enter code to define margin and dimensions for svg
        var margin = {top: 80, right: 120, bottom: 40, left: 100}
        var width = d3.select("#choropleth")
            .attr("width") - margin.left - margin.right

        var height = d3.select("#choropleth")
            .attr("height") - margin.top - margin.bottom

        // enter code to create svg
        var svg = d3.select("#choropleth")
            .attr("width", width)
            .attr("height", height)

        var countries = svg.select("#countries")
           // .attr("transform", "translate(" + margin.left + ", "+ 1.5*margin.bottom+")")
        // enter code to create color scale
        var myColors = ["#feedde","#fdbe85","#fd8d3c","#e6550d"]
        var colorQuantile = d3.scaleQuantile().range(myColors)

        // enter code to define tooltip
        var tooltip = d3.select("#tooltip") //div
            .attr('class', 'tooltip')
            .style("opacity", 0)
            .style("position", "absolute")
            .style("background", "lightgray") // Example styling
            .style("padding", "5px")
            .style("border-radius", "5px");
        // enter code to define projection and path required for Choropleth
        // For grading, set the name of functions for projection and path as "projection" and "path"

        var projection = d3.geoNaturalEarth()
            .translate([width/2.5, height/2])
            .scale(150)

        var path = d3.geoPath().projection(projection)

        Promise.all([d3.csv("ratings-by-country.csv"), d3.json("world_countries.json")
        ]).then(data => {
            var gameData = data[0]
            var world = data[1]
            var nestedRatings = d3.nest()
                .key(d => d.Country)
                .entries(gameData)

            var countryMap = new Map();

            world.features.forEach(feature => {
                countryMap.set(feature.properties.name, feature)
                    feature.properties.ratingValue = []
                    feature.properties.gameList = []
                    feature.properties.numUsers = []
            })

            nestedRatings.forEach(d => {
                var countryName = d.key;
                var feature = countryMap.get(countryName);
                if (feature) {
                    d.values.forEach(rate => {
                        var rateValue = parseFloat(rate["Average Rating"]);
                        var rateUser = parseFloat(rate["Number of Users"]);
                        feature.properties.ratingValue.push(rateValue);
                        feature.properties.gameList.push(rate.Game);
                        feature.properties.numUsers.push(rateUser);
                    });
                }
            })

            ready(null, world, gameData)
            })

        function ready(error, world, gameData) {
            console.log("i'm in ready function")//ready(error, world, gameData)
            if (error) throw error

            var gameNames = d3.map(gameData, d=>{ return d.Game; }).keys().sort(d3.ascending)

            var defaultGame = gameData[0]

            var dropOption = d3.select("#gameDropdown")
            dropOption.selectAll("option")
                .data(gameNames)
                .enter()
                .append("option")
                .text(d=>d)
                .attr("value", d=>d)

            var switchOption = function(){
                var game1 = d3.select(this).property('value')
                createMapAndLegend(world, gameData, game1)
            }

            createMapAndLegend(world, gameData, defaultGame)
            d3.select("#gameDropdown")
                .on("change", switchOption);




        }

        // this function should create a Choropleth and legend using the world and gameData arguments for a selectedGame
        // also use this function to update Choropleth and legend when a different game is selected from the dropdown
        function createMapAndLegend(world, gameData, selectedGame){
            console.log("i'm in createmaplegend function")

          //  var nestedData = d3.nest()
            //    .key(d => d.Game)
             //   .key(d => d.Country)
             //   .rollup(v => d3.mean(v, d => +d['Average Rating']))
             //   .entries(gameData);

            // Filter for the selected game and extract the country names and average ratings
          //  var selectedGameData = nestedData.find(d => d.key === selectedGame);
            var filteredData = gameData.filter(d => d.Game === selectedGame);

            var countryMap = filteredData.map(d => d.Country);
            var ratingsCountry = filteredData.map(d => +d['Average Rating']);
            var hold = ratingsCountry
console.log("ratingsCountry " + ratingsCountry)
         //   var countryMap = selectedGameData ? selectedGameData.values.map(d => d.key) : [];
          //  var hold = selectedGameData ? selectedGameData.values.map(d => d.value) : [];
           // var ratingsCountry = hold;

            var ratingSort = hold.sort(d3.ascending)

            var quantileSort = d3.scaleQuantile()
                .domain(ratingsCountry)
                .range(myColors)
console.log("right before countrypath")
            var countryPath = svg.append("g")
                .selectAll("paths")
                    .data(world)
                    .enter()
                    .append("path")
                    .attr("d", path)
                    .attr("stroke","black")
                    .on("mouseover", function(d, event) {
                        tooltip.show(d)
                        d3.select(this)
                            .style('stroke-width',3)
                            .style("left", (event.pageX + 5) + "px")
                            .style("top", (event.pageY - 28) + "px");

                   //     // Tooltip content logic
                  //      var avgRating = "N/A";
                 //       var numUsers = "N/A";
                 //       var dataExists = false
//
                 //       filteredData.forEach(v => {
                 //           if (v.Country === d.properties.name && v.Game === selectedGame) {
                  //              numUsers = +v['Number of Users'];
                   //             avgRating = +v['Average Rating'];
                    //            dataExists = true

                        })
                    .on("mousemove", function(event) {
                        tooltip.style("left", "4px")
                               .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function(d) {
                        tooltip.hide(d)
                        d3.select(this)
                            .style('stroke-width', 1)
                });
          // Format function for rounding
            var Dec2 = d3.format(".2f");

            var first = Dec2(d3.quantile(ratingSort,0)) + " to " + Dec2(d3.quantile(ratingSort, 0.25));
            var second = Dec2(d3.quantile(ratingSort,0.25)) + " to " + Dec2(d3.quantile(ratingSort, 0.50));
            var third = Dec2(d3.quantile(ratingSort,0.50)) + " to " + Dec2(d3.quantile(ratingSort, 0.75));
            var fourth = Dec2(d3.quantile(ratingSort,0.75)) + " to " + Dec2(d3.quantile(ratingSort, 1));
            var labels = [first,second,third,fourth]

            var legend = svg.select("#legend")

            legend.attr("class", "legendQuant")
                .attr("transform", "translate(" +width/1.4+", 20)")

            var legendColor = d3.legendColor()
                .labels(function(d) {return labels[d.i]}) // Use custom labels
                 .shapeWidth(20)
                 .orient("vertical")
                 .title("Average Rating")
                 .scale(quantileSort)
                 // Apply the color scale

            legend.call(legendColor)

            svg.append("text")
                .attr("transform", "translate(500,510)")
                .text("hpavlovich3");


            var colorScale = d3.scaleThreshold()
                .domain(hold.sort(d3.descending))
                .range(myColors)

            countryPath.style("fill", d=>{
                var emptyCountry = countryMap.indexOf(d.properties.name)
               // console.log("emptyCountry variable: " + emptyCountry)
                if (emptyCountry == -1) {
                    return "lightgray"
                }
                else{
                    var rating = ratingsCountry[emptyCountry]
                 //   console.log("in color find rating: " +emptyCountry +rating)
                 //   console.log("colorScale: " + colorScale(rating))
                    return colorScale(rating)
                }
            })
            
        }//.catch(function (error) {
      //console.log(error);
    </script>

</body>

</html>